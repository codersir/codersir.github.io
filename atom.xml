<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coder Sir</title>
  <subtitle>Yes! Coder sir.</subtitle>
  <link href="//atom.xml" rel="self"/>
  
  <link href="http://codersir.github.io/"/>
  <updated>2016-09-05T16:56:00.000Z</updated>
  <id>http://codersir.github.io/</id>
  
  <author>
    <name>xuhong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>三峡游</title>
    <link href="http://codersir.github.io/2016/09/05/Three-Gorges-Tour/"/>
    <id>http://codersir.github.io/2016/09/05/Three-Gorges-Tour/</id>
    <published>2016-09-04T17:37:46.000Z</published>
    <updated>2016-09-05T16:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>趁着离职的空档，和家人去宜昌三峡游玩了两天。第一次全家人一起出去游玩，本来就是想着休闲游，放松一下心情，所以尽兴倒是谈不上，开心更多的是因为满足了自己长久以来的一个小目标：<strong>带家人出去旅游</strong>。工作以后，陪家人的时间是越来越少了，从今年开始，希望以后每年都能至少全家人一起旅游一次。</p>
<a id="more"></a>
<h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>第一天（8.30）去了三峡人家。三峡人家过去需要坐船，好多年没坐船了，还是有点兴奋的，船上景色也非常不错。</p>
<p><img src="/image/threegores/xingchuan.jpeg" alt="行船"></p>
<p>自拍一张。</p>
<p><img src="/image/threegores/selfie.jpeg" alt="selfie"></p>
<p>船上偶遇 CCTV 拍纪录片。</p>
<p><img src="/image/threegores/cctv.jpeg" alt="CCTV"></p>
<p>三峡人家确实很美，你可以拍出和网上一模一样的照片。在山谷间溯流散步，空气清新，好不舒服。</p>
<p><img src="/image/threegores/sanxiarenjia.jpeg" alt="三峡人家"></p>
<p>一步一景美如画。</p>
<p><img src="/image/threegores/chuidizi.jpeg" alt="吹笛子"></p>
<h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>第二天（8.31）去的是三峡大坝，提前两天就在网上预约好了。本地人都说三峡大坝没什么看的，是宜昌各个著名景点里最无聊的一个。这个不说其实也能想到，就一个大坝，也不能上去，也不是泄洪期，能有什么看头呢？但这种标志性的景点不去又是不行的，不然就像没来过三峡一样。</p>
<p><img src="/image/threegores/sanxiadaba.jpeg" alt="三峡大坝"></p>
<p>在三峡大坝最开心的就是和家人合影照了很多照片，和每个人单独合影了，也一起拍了「全家福」，非常宝贵，就不放出来了。放一张我拍的小公主。</p>
<p><img src="/image/threegores/niuniu.jpeg" alt="niuniu"></p>
<h3 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h3><p>原本计划游玩三天的，但是玩了两天后就感觉没什么意思了，原计划去清江画廊的也就未能成行，第三天就打道回府了。另外，今天拿到了阿里的口头 offer ，然后拒绝了。一个月的面试也随着旅行的结束而告一段落了，想想自己其实没投几个公司，但是投的几个都给了 offer，也算是一种认可吧。</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>这次的出行比较匆忙，是姐姐临时起的意，并没有多少时间安排，所以就选了比较近的城市，总的来说还是不错的。宜昌是个典型的旅游城市，各种旅游业务很发达，景点坐车都很方便，依山傍水，空气清新，蛮适合带孩子和老人出来休闲游的。</p>
<p>明年的家庭游目的地也已经想好了，自然是杭州啦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;趁着离职的空档，和家人去宜昌三峡游玩了两天。第一次全家人一起出去游玩，本来就是想着休闲游，放松一下心情，所以尽兴倒是谈不上，开心更多的是因为满足了自己长久以来的一个小目标：&lt;strong&gt;带家人出去旅游&lt;/strong&gt;。工作以后，陪家人的时间是越来越少了，从今年开始，希望以后每年都能至少全家人一起旅游一次。&lt;/p&gt;
    
    </summary>
    
    
      <category term="travel" scheme="http://codersir.github.io/tags/travel/"/>
    
  </entry>
  
  <entry>
    <title>Redux 生态系统</title>
    <link href="http://codersir.github.io/2016/07/06/redux-ecosystem/"/>
    <id>http://codersir.github.io/2016/07/06/redux-ecosystem/</id>
    <published>2016-07-05T17:35:39.000Z</published>
    <updated>2016-08-01T13:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>在学习 React 的过程中，我们了解到 React 组件其实是<a href="https://github.com/nixzhu/dev-blog/blob/master/2015-04-23-state-machine.md" target="_blank" rel="external">状态机</a>，那么，随着应用庞大组件多起来，就不可避免的会面临状态管理的问题。最初，facebook 官方推荐的状态管理方案是 <a href="https://facebook.github.io/flux" target="_blank" rel="external">Flux</a>，开源社区也产生了许多基于 Flux 的变种，比如 <a href="http://fluxxor.com/" target="_blank" rel="external">fluxxor</a>，相较 Flux 都有所改进，但和官方背景顶多能达到分庭抗礼，却无法一统江湖。直到 Redux 横空出世，以更简洁直接的方案和对中间件的支持，在社区中迅速获得大量的拥趸，现在几乎已经成了 React 应用的标配。由于对中间件的支持，开源社区产出了许多优秀的 Redux 中间件，比如 redux-logger, redux-undo, redux-thunk 等，慢慢的形成了一个完善的生态系统。官方文档页面也有一个 <a href="http://redux.js.org/docs/introduction/Ecosystem.html" target="_blank" rel="external">Ecosystem</a> 页面，列出了各种 Reudx 相关的中间件、组件和小工具等，本文主要介绍我日常开发中用到并且深入学习了的中间件，并结合源码解释其工作原理。</p>
<blockquote>
<p>如果你还不了解 Redux，可以看我写的「<a href="/2016/01/25/dive-into-redux/">深入学习 Redux</a>」。</p>
</blockquote>
<a id="more"></a>
<h2 id="Redux-中间件"><a href="#Redux-中间件" class="headerlink" title="Redux 中间件"></a>Redux 中间件</h2><p>如果你了解 express 或 koa，那么你应该对中间件的概念很熟悉了，这些框架的中间件作用在接到请求和返回响应之间，进行 log 日志、添加 CORS 头等任务，中间件的最大特点就是它们可以链式组合。 Redux 中间件虽然处理的问题不一样，但是它们概念上是相似的。Redux 中间件<strong>作用在分发 action 和被 reducer 处理之间</strong>。官方文档对 <a href="http://redux.js.org/docs/advanced/Middleware.html" target="_blank" rel="external">Redux middleware</a> 有一个很好的介绍，通过一步步改进一个 logger 中间件让你理解中间件的机制，推荐查看。以文档 logger 中间件为例，展示一个标准 Redux 中间件的写法：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> logger = store =&gt; <span class="keyword">next</span> =&gt; action =&gt; &#123;</div><div class="line">  console.<span class="built_in">log</span>(<span class="string">'dispatching'</span>, action)</div><div class="line">  let result = <span class="keyword">next</span>(action)</div><div class="line">  console.<span class="built_in">log</span>(<span class="string">'next state'</span>, store.getState())</div><div class="line">  <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Redux 中间件接受 store 作为参数，并返回一个新的函数，这个函数会成为 Redux 中间件链上的一环，当调用 dispatch 函数的时候，会依次穿过所有的中间件。</p>
<h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>Redux 是一种状态管理方案，虽然主要在 React 社区大放异彩，但是它并不限于和 React 一起使用。如果结合 React 使用，则最好配合这个包一起用，这个包提供两个 API，<code>Provider</code> 组件和 <code>connect()</code> 方法：</p>
<ul>
<li><code>Provider</code><br><code>Provider</code> 组件的作用是挂载 store 到全局，使得每个组件都可以方便的获取 <code>store</code>。它的实现很简单，就是把 <code>Provider</code> 组件作为根组件，通过 React <a href="https://facebook.github.io/react/docs/context.html" target="_blank" rel="external">context</a> 机制，挂载 <code>store</code> 到所有子组件 context 的上。</li>
<li><code>connect</code><br><code>connect</code> 是一个工具函数，它的作用是关联 state 到 React 组件，通过映射函数，关联 store 上相关的 state 到 React 组件的 props，在 store 发生变化时自动更新组件的 props。</li>
</ul>
<h2 id="redux-actions"><a href="#redux-actions" class="headerlink" title="redux-actions"></a>redux-actions</h2><p>action 是描述发生了什么的对象，它是 Redux 中最简单的概念。对 action 对象只有一个限制，那就是包含一个合适的 <code>type</code> 字段，所以大家可能写出各种各样的 action。宽松对个人是一种自由，但是对团队则会造成混乱，产生不必要的沟通成本。所以 action 需要一个规范，社区用的最多的是 <a href="https://github.com/acdlite/flux-standard-action" target="_blank" rel="external">FSA</a>。redux-actions 就是用来创建符合 FSA 规范的 actions，同时提供工具函数方便处理 actions。它有下面三个 API：</p>
<ul>
<li><code>createAction(type, payloadCreator = Identity, ?metaCreator)</code><br>其实这个函数名叫<code>createActionCreator</code> 更合理，它将会返回一个 action creator 函数，creator 函数的返回值是一个符合 FSA 标准的 action，但是也有自己的扩展，也就是 <code>meta</code>，结构如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">type</span>: <span class="built_in">String</span></div><div class="line">  payload, <span class="built_in">any</span></div><div class="line">  error?: <span class="built_in">Boolean</span></div><div class="line">  meta?: <span class="built_in">any</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><code>handleAction(type, reducer | reducerMap, ?defaultState)</code><br>这个函数包装 reducer 让它只处理特定类型的 FSA。第二个参数可以是 reducer 函数或者是 reducer 对象，如果是对象，要采用下面的格式（灵感来自 generator）：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  next(state, action)<span class="meta">&#123;...&#125;</span>,</div><div class="line">  throw(state, action)<span class="meta">&#123;...&#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>handleActions(reducerMap, ?defaultState)</code><br>这个函数通过 <code>handleAction</code> 创建多个 reducers，并且把它们组合成一个可以处理多个 actions 的单一 reducer，合并 reducers 调用的是下面这个函数：</p>
</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">export <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">reduceReducers</span><span class="params">(<span class="rest_arg">...reducers</span>)</span> </span>&#123;</div><div class="line">  <span class="comment">// 改成 `return (defaultState, action)` 更好理解</span></div><div class="line">  <span class="keyword">return</span> (previous, current) =&gt;</div><div class="line">    reducers.reduce(</div><div class="line">      (p, r) =&gt; r(p, current),</div><div class="line">      previous</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数返回函数的参数名让人容易误解，把它改成 <code>(defaultState, action)</code> 就容易理解了，举个例子：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> reducersMap = &#123;</div><div class="line">    <span class="type">ADD_TODO</span>: (state, action) =&gt; <span class="meta">&#123;...&#125;</span>,</div><div class="line">    <span class="type">TOGGLE_TODO</span>: (state, action) =&gt; <span class="meta">&#123;...&#125;</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> reducer = handleActions(reducersMap, &#123;todos: []&#125;)</div><div class="line">// 最后返回的 reducer 为：</div><div class="line">（defaultState, action) =&gt; reducersMap['<span class="type">TOGGLE_TODO</span>'](reducersMap['<span class="type">ADD_TODO</span>'](defaultState, action), action)</div></pre></td></tr></table></figure>
<h2 id="redux-logger"><a href="#redux-logger" class="headerlink" title="redux-logger"></a>redux-logger</h2><p>官方文档的 logger 示例还是太简单了，有时候我们需要更详细的日志信息，比如 action 的具体信息、触发的时间、异步 action 的耗时、state 的具体变化等，甚至 log 的级别和颜色、格式化 log 信息，这些 <a href="https://github.com/evgenyrodionov/redux-logger" target="_blank" rel="external">redux-logger</a> 都很贴心的提供了。logger 中间件很简单，API 可以去 github 查看，使用时需要注意的就是<strong> Logger 只能是最后一个中间件</strong>。</p>
<h2 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h2><p>通常说 <a href="https://en.wikipedia.org/wiki/Thunk" target="_blank" rel="external">thunk</a> 函数是指通过包裹表达式使之延迟执行的函数，以达到“传名调用”提高性能的效果。JS 是“传值调用”的语言，它的 thunk 函数其实是指“部分函数”（或者说部分柯里化），把一个多参数函数变成一个单参数函数，而且参数为回调函数。redux-thunk 允许 action creator 返回一个函数而不是 action，它的功能就是使 dispatch action 延迟执行。它源码是最简单的，只有区区十几行:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span><span class="params">(extraArgument)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (typeof action === <span class="string">'function'</span>) &#123;</div><div class="line">      <span class="keyword">return</span> action(dispatch, getState, extraArgument);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> next(action);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> thunk = createThunkMiddleware();</div><div class="line">thunk.withExtraArgument = createThunkMiddleware;</div><div class="line"></div><div class="line">export <span class="keyword">default</span> thunk;</div></pre></td></tr></table></figure>
<p>源码也很容易理解，如果 action 是一个函数，那么就传入一些参数调用它，否则就不进行任何操作直接传给下一个中间件。 <a href="https://github.com/gaearon/redux-thunk#composition" target="_blank" rel="external">github</a> 上有个详细的例子，用来解释 redux-thunk 是如何优化异步流程控制的。</p>
<h2 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h2><p>当看到 redux-thunk 的时候，心里就想着那么是否有 「redux-co」 呢？同样是异步流程控制，NodeJS 中有 <a href="https://github.com/thunks/thunks" target="_blank" rel="external">thunks</a> 和 <a href="https://github.com/tj/co" target="_blank" rel="external">co</a>，分别代表基于 callback 和基于 generator 的的异步流程控制。后来发现还真有，那就是 <a href="https://github.com/yelouafi/redux-saga" target="_blank" rel="external">redux-saga</a>。虽然官方文档主推 redux-thunk，但是 redux-saga 凭借自身机制的优势，已经超越 redux-thunk 获得了更大的关注，成为事实的标准，算是另一个社区产出超越官方主推的例子。</p>
<blockquote>
<p>如果你还不了解 co， 可以看我写的 「<a href="/2016/06/17/dive-into-koa/">Koa 是怎么让你爽的？</a>」</p>
</blockquote>
<p>和 co 一样，redux-saga 也是基于 generator 的。redux-saga 是测试驱动的典型，它提供了许多 effect 构造器，用来处理异步操作的同时保持代码的可测试性。redux-saga 比较复杂，详细介绍和 API 可以查看<a href="https://yelouafi.github.io/redux-saga" target="_blank" rel="external">官方文档</a>，后面也许会单独写一篇博客分析它的工作原理。</p>
<h2 id="reselect"><a href="#reselect" class="headerlink" title="reselect"></a>reselect</h2><p>学习这些组件的过程中，最让我开心的是 <strong>看到思想的闪光</strong>，以及大家对这些想法的热情。很多组件实现其实都很简单，短短几十行或上百行代码，但却能完美的达到某一目的。比如 reselect，只有几十行代码，实现功能也非常简单，通过记忆函数来优化 React 性能，收获了 3000 多的 star，前端组件生态终于开始有点 NodeJS package 的感觉了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习 React 的过程中，我们了解到 React 组件其实是&lt;a href=&quot;https://github.com/nixzhu/dev-blog/blob/master/2015-04-23-state-machine.md&quot;&gt;状态机&lt;/a&gt;，那么，随着应用庞大组件多起来，就不可避免的会面临状态管理的问题。最初，facebook 官方推荐的状态管理方案是 &lt;a href=&quot;https://facebook.github.io/flux&quot;&gt;Flux&lt;/a&gt;，开源社区也产生了许多基于 Flux 的变种，比如 &lt;a href=&quot;http://fluxxor.com/&quot;&gt;fluxxor&lt;/a&gt;，相较 Flux 都有所改进，但和官方背景顶多能达到分庭抗礼，却无法一统江湖。直到 Redux 横空出世，以更简洁直接的方案和对中间件的支持，在社区中迅速获得大量的拥趸，现在几乎已经成了 React 应用的标配。由于对中间件的支持，开源社区产出了许多优秀的 Redux 中间件，比如 redux-logger, redux-undo, redux-thunk 等，慢慢的形成了一个完善的生态系统。官方文档页面也有一个 &lt;a href=&quot;http://redux.js.org/docs/introduction/Ecosystem.html&quot;&gt;Ecosystem&lt;/a&gt; 页面，列出了各种 Reudx 相关的中间件、组件和小工具等，本文主要介绍我日常开发中用到并且深入学习了的中间件，并结合源码解释其工作原理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你还不了解 Redux，可以看我写的「&lt;a href=&quot;/2016/01/25/dive-into-redux/&quot;&gt;深入学习 Redux&lt;/a&gt;」。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://codersir.github.io/tags/react/"/>
    
      <category term="redux" scheme="http://codersir.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>Koa 是怎么让你爽的？</title>
    <link href="http://codersir.github.io/2016/06/17/dive-into-koa/"/>
    <id>http://codersir.github.io/2016/06/17/dive-into-koa/</id>
    <published>2016-06-17T09:15:36.000Z</published>
    <updated>2016-06-18T18:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>经常在网路上看到别人夸 Koa 写的爽，有的甚至产生了「优越感」，但写的都是种种爽的体位，却没有看到有谁详细解释为什么可以采用这些体位，以及为什么这些体位爽。其实，只要看一下 Koa 的源码，就可以知道这些原因。</p>
<a id="more"></a>
<p>当然，还是要有一些准备知识的，你需要知道 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="external">generator</a> 是什么？<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield" target="_blank" rel="external">yield</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*" target="_blank" rel="external">yield *</a> 是怎么工作的？这些都可以在 <a href="https://developer.mozilla.org/" target="_blank" rel="external">MDN</a> 上获取到，这里只分析 Koa 的实现，假设你已经掌握了以上必需的知识。</p>
<blockquote>
<p>以下代码分析基于 Koa V1.x。</p>
</blockquote>
<p>爽发生在中间件的写法上面。Koa 使用一个数组来维护所有的中间件（middleware），通过调用 <code>app.use</code> 把中间件添加到这个数组中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.use = <span class="function"><span class="keyword">function</span>(<span class="params">mdw</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.middleware.push(mdw)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中中间件是 generator 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mdw = <span class="function"><span class="keyword">function</span> *(<span class="params">next</span>)</span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>然后在请求过来的时候，http server 会调用 Koa 的 callback，然后请求通过 Koa 中间件，最后返回结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">app.callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> fn = co.wrap(compose(<span class="keyword">this</span>.middleware))</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</div><div class="line">    fn.call(...)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要流程就是这样了，Koa 之所以支持那些很爽的写法，就是来自下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">co.wrap(compose(<span class="keyword">this</span>.middleware))</div></pre></td></tr></table></figure>
<p>那么这段代码究竟有什么黑魔法？且听我慢慢道来。</p>
<p>第一步，组合中间件，调用 <code>compose</code> 函数并传入中间件数组作为参数，<code>compose</code> 的实现非常简单，源码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">middleware</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> *(<span class="params">next</span>)</span>&#123;</div><div class="line">     <span class="keyword">if</span> (!next) next = noop();</div><div class="line">     <span class="keyword">var</span> i = middleware.length;</div><div class="line">     <span class="keyword">while</span> (i--) &#123;</div><div class="line">       next = middleware[i].call(<span class="keyword">this</span>, next);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">yield</span> *next;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">noop</span>(<span class="params"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure>
<p><code>compose</code> 函数组合中间件的方式很巧妙，它递归地把后一个中间件调用返回的 generator 对象作为参数传给上一个中间件进行调用，<code>while</code> 循环结束后，<code>next</code> 值为第一个中间件传入第二个中间件调用后的 generator 对象为参数进行调用后返回的 generator 对象。是不是有点绕？那来点简单的代码解释一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">noop</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">log</span>(<span class="params">next</span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span></div><div class="line">    <span class="keyword">yield</span> next</div><div class="line">    <span class="keyword">yield</span> <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">next</span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">compose</span>(<span class="params">next</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!next) &#123; next = noop() &#125;</div><div class="line">    next = gen(next)</div><div class="line">    next = log(next)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">yield</span> * next</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = compose()</div><div class="line"><span class="built_in">console</span>.log(a.next()) <span class="comment">// &#123;value: 1, done: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(a.next()) <span class="comment">// &#123;value: gen, done: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(a.next()) <span class="comment">// &#123;value: 3, done: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(a.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure>
<p>通过输出可以看出，在 Koa 中，我们通过调用 <code>yield next</code> 跳转出当前中间件，从 log 中间件跳到了 gen，然后又回到了 log。但是这里有个问题，我们希望输出的 2 并没有出现，所以并没有完全达到我们的期望。所以，接下来，该 co 登场了。</p>
<p>注意，<code>compose</code> 函数并没有立即就组合中间件，而是返回一个 generator 函数 gen:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">gen = <span class="function"><span class="keyword">function</span> *(<span class="params">next</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span> (!next) next = noop();</div><div class="line">  <span class="keyword">var</span> i = middleware.length;</div><div class="line">  <span class="keyword">while</span> (i--) &#123;</div><div class="line">    next = middleware[i].call(<span class="keyword">this</span>, next);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">yield</span> *next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二步，调用 <code>co.wrap()</code> 函数，传入上一步 <code>compose</code> 返回的 <code>gen</code> 函数作为参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fn = co.wrap(gen)</div></pre></td></tr></table></figure>
<p>查看 co 的源码，<code>co.wrap()</code> 函数返回一个辅助函数 <code>createPromise</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fn = <span class="function"><span class="keyword">function</span> <span class="title">createPromise</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> co.call(<span class="keyword">this</span>, gen.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回到上面 Koa 的 callback 源码，http 请求过来的时候，fn 函数调用，此时执行 <code>gen</code> 函数，并将结果作为参数传给 <code>co</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">co.call(<span class="keyword">this</span>, gen.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>))</div></pre></td></tr></table></figure>
<p>注意：</p>
<blockquote>
<p> <strong>generator 函数在被调用的时候，函数体并不会立马执行，只是返回一个 generator 对象，调用 generator 对象的 next 方法的时候，才会执行函数体</strong>，并且在遇到 yield 的时候暂停执行。</p>
</blockquote>
<p>所以，这时候，中间件仍然没有组合，直到进入 co 中，<code>onFulfilled()</code> 函数内部调用 <code>gen.next()</code> 的时候，<code>compose</code> 函数返回的 generator 函数体才得以执行。这就是为什么进入 co 后立马调用 <code>onFulfilled()</code> 函数的原因。</p>
<p>我们知道 Koa 中，中间件是 generator 函数，所以去掉其他条件判断，co 处理中间件的主要代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.apply(ctx, args);</div><div class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</div><div class="line"></div><div class="line">    onFulfilled();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> ret;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        ret = gen.next(res);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        <span class="keyword">return</span> reject(e);</div><div class="line">      &#125;</div><div class="line">      next(ret);</div><div class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> ret;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        ret = gen.throw(err);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        <span class="keyword">return</span> reject(e);</div><div class="line">      &#125;</div><div class="line">      next(ret);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</div><div class="line">      <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</div><div class="line">      <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</div><div class="line">      <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></div><div class="line">        + <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPromise</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (isGeneratorFunction(obj) || isGenerator(obj)) <span class="keyword">return</span> co.call(<span class="keyword">this</span>, obj);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么，上面的那个 2 是怎样输出来的呢？实现其实很简单：</p>
<p>co 反复调用内部的 next() 函数，判断上一次遍历器的返回值状态，如果它未结束并且是 GeneratorFunction 或是 Generator 对象，就再次把它作为参数传入 <code>co</code> 函数调用。</p>
<p>借由这样的机制，Koa 就可以在 <code>yield next</code> 被调用的时候进入下一个中间件，再遇到 <code>yield next</code> 进入下下个或者遍历结束返回上一个，Koa 文档有一张 Gif 很形象的描述了 Koa 中间件这种机制：</p>
<p><img src="https://github.com/koajs/koa/blob/master/docs/middleware.gif?raw=true" alt="co middleware"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常在网路上看到别人夸 Koa 写的爽，有的甚至产生了「优越感」，但写的都是种种爽的体位，却没有看到有谁详细解释为什么可以采用这些体位，以及为什么这些体位爽。其实，只要看一下 Koa 的源码，就可以知道这些原因。&lt;/p&gt;
    
    </summary>
    
    
      <category term="koa" scheme="http://codersir.github.io/tags/koa/"/>
    
      <category term="nodejs" scheme="http://codersir.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS 应用优化指南</title>
    <link href="http://codersir.github.io/2016/05/10/AngularJS-app-performance-optimization-guide/"/>
    <id>http://codersir.github.io/2016/05/10/AngularJS-app-performance-optimization-guide/</id>
    <published>2016-05-10T08:15:33.000Z</published>
    <updated>2016-08-01T13:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/ng-perf/batarang.jpg" alt="Batarang"></p>
<p>前两天因为想用国内的 JS CDN，访问到 <a href="http://www.staticfile.org/" target="_blank" rel="external">staticfile</a>（七牛提供的一个免费 CDN 服务），导致我的 Chrome 直接卡死了两次，页面关也关不掉，只能退出重启。后来换到 Chrome Canary 才勉强可以访问，用谷歌开发者工具一看，发现前端是用的 AngularJS ，大量的 <code>ng-repeat</code>，5万多 <code>watcher</code>，没有做任何性能优化，怎么可能不卡。<br><a id="more"></a></p>
<p><img src="/image/ng-perf/staticfile.png" alt="Profile"></p>
<p>今年以来一直在陆陆续续的优化公司基于 AngularJS 开发的应用，也积累了一些经验，正好总结一下 AngularJS webapp 的性能优化指南。</p>
<h3 id="1-减少-watcher"><a href="#1-减少-watcher" class="headerlink" title="1. 减少 watcher"></a>1. 减少 <code>watcher</code></h3><p>我们知道 AngularJS 通过 <em>脏检查</em>（digest cicle）来更新视图，保持数据和视图的同步，脏检查的效率是和 <code>watcher</code> 的多少成正相关的，一般来说超过 2000 后就会明显感觉到变慢，所以提高 AngularJS 性能的关键就是减少 <code>watcher</code> 的数量。</p>
<p>首先，我们要知道的是，<strong>什么会产生 <code>watcher</code></strong> ？</p>
<ul>
<li><code>$scope.$watch</code></li>
<li><code>{ { stuff } }</code> 类模板语法</li>
<li>大多数指令 (比如 <code>ng-show</code>、<code>ng-if</code>)</li>
<li>Scope 变量 <code>scope: { bar: &#39;=&#39;}</code></li>
<li>过滤器 <code>{ { value | myFilter } }</code></li>
<li><code>ng-repeat</code> 指令</li>
</ul>
<p>上面这些情况都会产生 <code>watcher</code>，那么问题来了，<strong>怎么减少 <code>watcher</code></strong> 呢?</p>
<ol>
<li>使用单次绑定语法 <code>{ {::} }</code><br>AngularJS 从1.3版本开始支持单向绑定语法 <code>::</code> ，它可以明确的告诉 AngularJS 哪些绑定获取到数据以后就不用关注了，这可以极大的减少 <code>watcher</code> 的数量，尤其是在 <code>ng-repeat</code> 内使用。</li>
<li>避免在 <code>ng-repeat</code> 中使用 <code>filter</code><br>可以先把数据过滤后再传给 <code>ng-repeat</code>，这样就能避免因为过滤器产生的 <code>watcher</code> 了。</li>
<li>尽可能的使用 <code>ng-if</code> 而不是 <code>ng-show</code><br><code>ng-if</code> 可以从 Dom 中移除元素，触发 <code>element.$destory()</code>，删除 <code>ng-if</code> 内的元素的 <code>watcher</code>。<code>ng-show</code> 仍然会 render 元素，只是设置样式为 <code>display:none</code>。 但是如果元素需要经常变动隐藏还是显示，那么使用 <code>ng-show</code> 可能会更好，<code>ng-show</code> 会缓存 Dom，不需要重复解析。</li>
<li>使用 <code>$watchCollection</code> 替代 <code>$watch</code></li>
</ol>
<h3 id="2-减少-digest-次数和范围"><a href="#2-减少-digest-次数和范围" class="headerlink" title="2. 减少 digest 次数和范围"></a>2. 减少 <code>digest</code> 次数和范围</h3><p>减少 <code>watcher</code> 是从根本上解决问题，如果 <code>watcher</code> 的优化已经做到极致了，那么这时候就应该换一种思路了。导致 AngularJS App 变慢的原因是 <code>watcher</code> 太多导致 <code>digest</code> 变慢，<code>watcher</code> 已经无法优化了，那么就应该考虑从 <code>digest</code> 的下手了。</p>
<p>同样，首先要知道的是，什么情况下会触发 AngularJS 脏检查？</p>
<ul>
<li>用户行为（<code>ng-click</code>、<code>ng-change</code>、<code>ng-model</code>,etc)</li>
<li><code>$http</code> 接口响应</li>
<li><code>$q</code> promises resolved</li>
<li>使用 <code>$timeout</code> 和 <code>$interval</code></li>
<li>你手动调用 <code>$scope.$apply</code> 或 <code>$scope.$digest</code></li>
</ul>
<p>优化主要从两个方向进行，<strong>减少脏检查的次数</strong> 和 <strong>缩小脏检查的范围</strong>。</p>
<ol>
<li><p>尽量使用 <code>$scope.$digest</code> 替代 <code>$scope.$apply</code><br><code>$scope.$digest</code> 从当前 scope 向下进行脏检查，而 <code>$scope.$apply</code> 会触发整个应用自顶向下进行脏检查，所以，使用 <code>$scope.$digest</code> 一般能大大的缩小脏检查的范围。</p>
</li>
<li><p>使用 <code>$applyAsync</code> 合并 http 请求<br>通常在 App 启动的时候，会同时发起好几个 http 请求，来获取用户权限或账户信息之类的信息，每次接口返回值的时候，都会触发 AngularJS 的脏检查。这时候，如果可以等到这几个接口都返回以后，再触发脏检查，就能将脏检查的数量由几次减小到1次了。<code>$httpProvider</code> 的 <a href="https://code.angularjs.org/1.3.8/docs/api/ng/provider/$httpProvider#useApplyAsync" target="_blank" rel="external">useApplyAsync</a> 方法就是来解决这个问题，它通过 <a href="https://code.angularjs.org/1.3.8/docs/api/ng/type/$rootScope.Scope#$applyAsync" target="_blank" rel="external"> $rootScope.$applyAsync</a> 把大约同一时间（10ms左右）收到的返回值组合到一起处理。<code>applyAsync</code>的实现机制其实就是事件循环，通过 <code>setTimeout(fn,0)</code> 来延迟执行函数，可以参考我写的<a href="/2016/03/13/dive-into-zone/">《深入学习 Zone》</a>了解更多。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.config(<span class="function"><span class="keyword">function</span> (<span class="params">$httpProvider</span>) </span>&#123;</div><div class="line">  $httpProvider.useApplyAsync(<span class="literal">true</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>ng-model 防抖动（ Debounce ）<br>搜索框通常会监听用户的 keyup 事件来进行实时匹配推荐，如果每次用户按下按键都调用接口，会出现多次连续的调用接口，导致连续的触发 AngularJS 脏检查，这样很容易造成页面卡顿。这时，可以通过 <code>ng-model</code> 的 <code>debounce</code> 参数来限制脏检查的间隔，比如 <code>ng-model-options=&quot;{ debounce: 250 }</code>，限制每 250ms 内只进行一次脏检查。</p>
</li>
<li><p>使用 <code>$watchCollection</code> 替代 <code>$watch</code> 的第三个参数<br><code>$watch</code> 只会比较对象引用是否相同，如果新值和原始值指向同一个索引，那么 <code>$digest</code> 时就不会触发回调函数。如果要监视对象的每个属性，我们可以给 <code>$watch</code> 传入第三个参数 <code>true</code>，这样 AngularJS 就会对对象进行深比较（使用 <code>angular.equals</code>)，遍历对象的每个值判断是否发生了变化。但如果对象比较复杂，这样做就会带来很大的性能损耗。所以，AngularJS 提供了 <code>$watchCollection</code> 方法来解决这一问题。<code>$watchCollection</code> 在脏检查的时候对对象进行浅比较，只会比较对象的第一层属性。</p>
</li>
<li><p>尽量把 DOM 操作移到指令中<br>比如 <code>ng-show</code> 和 <code>ng-hide</code>，我们经常通过这些指令来控制元素的显示和隐藏，但这些指令的表达式值都会被 AngularJS 监听，导致 <code>watcher</code> 增加，而且这些值的变化通常也会引发 AngularJS 的 digest。我们应该尽可能的把这些逻辑移到指令的 <code>link</code> 函数中。当然，这一点最后考虑。</p>
</li>
</ol>
<h3 id="3-其他建议"><a href="#3-其他建议" class="headerlink" title="3. 其他建议"></a>3. 其他建议</h3><ol>
<li><p>使用 <code>track by</code> 提高 <code>ng-repeat</code>性能</p>
</li>
<li><p>禁用 debug 信息 我们看到使用 AngularJS 指令的元素上被添加了许多类，比如 <code>ng-binding</code>、<code>ng-scope</code>等，这些类除了调试没有任何作用，</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$compileProvider.debugInfoEnabled(<span class="literal">false</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>耗时的计算考虑移到 web workers 执行</p>
</li>
</ol>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>怎么测时间都花在哪了？如果我们担心某个函数会很耗时，可以简单的把<code>console.time()</code> 和 <code>console.timeEnd()</code> 放在代码的前后来测试代码的运行时间。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.time(<span class="string">'myTimer'</span>)</div><div class="line"><span class="comment">// your code here</span></div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'myTimer'</span>)</div></pre></td></tr></table></figure>
<p>这两个函数可以帮助我们测试某一小段代码的运行时间，如果要观测整个应用的运行时间，就要使用下面这两个工具了：</p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk" target="_blank" rel="external">AngularJS Batarang</a></li>
<li>Chrome Timeline</li>
</ul>
<p>具体怎么使用这两种工具就不细说了，尤其是 Chrome 开发者工具，每个前端工程师都应该学会用它进行性能调优。</p>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Batarang" target="_blank" rel="external">Batarang</a> 是一种很有意思的武器，蝙蝠形状的回旋刀，是各种电影动画里面蝙蝠侠的武器。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从去年下半年开始，国内很多大公司都开始用 AngularJS 开发用户后台了，比如 upyun、 Ucloud（新版 UCloud 用户后台做的很不错） 和 阿里云。但 F12 查看源代码就会发现，基本上都没有做任何的性能优化。当然，现在电脑性能基本上都处于过剩的状态，即使不做任何优化，只要页面的 <code>watcher</code> 数量没有多到 staticfile 那样，基本上也不会有什么问题，最多就是把页面响应时间从几百毫秒提升到几十毫秒，1s 以内通常用户都是还可以接受的。但作为一个有追求的程序猿，对自己开发的产品有归属感，你还是可以明显感受到几百毫秒到几十毫秒的巨大差异的。另外一个就是代码规范，社区已经有许多最佳实践了，借鉴最佳实践来改善自己的代码风格是另一个优化的方向。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://www.alexkras.com/11-tips-to-improve-angularjs-performance/" target="_blank" rel="external">11 Tips to Improve AngularJS Performance</a></li>
<li><a href="http://www.codelord.net/2014/06/17/angular-performance-101-slides/" target="_blank" rel="external">Angular Performance 101</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/image/ng-perf/batarang.jpg&quot; alt=&quot;Batarang&quot;&gt;&lt;/p&gt;
&lt;p&gt;前两天因为想用国内的 JS CDN，访问到 &lt;a href=&quot;http://www.staticfile.org/&quot;&gt;staticfile&lt;/a&gt;（七牛提供的一个免费 CDN 服务），导致我的 Chrome 直接卡死了两次，页面关也关不掉，只能退出重启。后来换到 Chrome Canary 才勉强可以访问，用谷歌开发者工具一看，发现前端是用的 AngularJS ，大量的 &lt;code&gt;ng-repeat&lt;/code&gt;，5万多 &lt;code&gt;watcher&lt;/code&gt;，没有做任何性能优化，怎么可能不卡。&lt;br&gt;
    
    </summary>
    
    
      <category term="AngularJS" scheme="http://codersir.github.io/tags/AngularJS/"/>
    
      <category term="perf" scheme="http://codersir.github.io/tags/perf/"/>
    
  </entry>
  
  <entry>
    <title>西安四日游</title>
    <link href="http://codersir.github.io/2016/05/01/4-days-in-xian/"/>
    <id>http://codersir.github.io/2016/05/01/4-days-in-xian/</id>
    <published>2016-05-01T14:59:46.000Z</published>
    <updated>2016-05-29T18:17:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>去年五一去的庐山，排队的惨烈还历历在目，于是今年就和女朋友决定五一不出去玩了。五一之前请了两天假加上周末，去西安玩了4天，五一就待在家里把游记补上。<br><a id="more"></a><br>也许是武汉呆的太久了了，西安这个城市让我感觉很舒服。生活节奏适中，虽然没有恩施、成都那么的安逸闲散，但比武汉的风风火火确实是好上许多。西安是一座平静的城市，无论是城市还是生活在其中的人，都让你有种不紧不慢的感觉，踩着自己舒适的节奏。</p>
<p>西安城很小，这城指的是城墙内的城。城内没有很高的建筑，十层以上的都没有看到过，大都是5层以内的，行走在其中完全没有大城市高楼大厦带来的逼仄感。城内绿化做得很好，种了许多的树，有不少是柳树，春天里漫天飞舞的柳絮给西安人也造成了不小的困扰。</p>
<p>西安城内大街小巷大都是横平竖直的，以钟楼为中心，上下左右四个方向是西安城东西南北的基准线，因此西安人的方位感都很好，在西安和滴滴司机碰头所有司机都是用的方位词，让我这个路痴定位得好辛苦。在西安的四天基本都在打滴滴，和西安人接触的最多的，就是西安的滴滴车司机。也许是我运气好，但我更愿意相信这是这个城市素质的体现，我接触的每个滴滴司机都很热情和健谈。他们对这个城市有自己的理解，并且愿意与游客分享。</p>
<p>西安作为一个旅游城市，旅游服务体验确实很好。去秦始皇兵马俑有专门开设的旅游专线，旅游专线巴士解说员专业而干练，解说简明扼要，没有一丝的废话和任何产品推销，毫不夸张的说，这是我体验过的最好的一次旅游解说。秦始皇兵马俑在外国人心中，应该是和长城一样的存在，属于没去就算白来中国的景点。西安城内有许多的外国人，最后都聚集在这里。逛完兵马俑出来的时候，发现外面公园的松树下和道路一旁的石凳上，坐满了来自世界各地的游客。</p>
<p>接触西安，以一张地铁票开始。</p>
<p><img src="/image/xian/ticket.jpg" alt="西安地铁票"></p>
<h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>第一天天气不好，下着小雨，刮着大风，所以选择了在城内的回民街和鼓楼。</p>
<p>回民街和各个城市的小吃一条街一样，不出所料的让我们失望了，所有的食物都很咸很咸，咸的泛苦了。后来和滴滴车司机聊天，有个师傅说，回民街本地人都不去吃，那些东西吃多了高血压。<br><img src="/image/xian/momo.jpg" alt="回民街羊肉泡馍"></p>
<p>鼓楼和钟楼没隔多远，但我们只去了鼓楼，因为听别人说上面的鼓乐表演还不错，确实也没有让我们失望，国外游客对这些表演尤其感兴趣。</p>
<p><img src="/image/xian/gulou.jpg" alt="鼓楼合影"></p>
<h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>第二天天气好了起来，可以出远门了，所以去了临潼的华清池和秦始皇兵马俑。</p>
<p>出门晚了一点，旅游专线的巴士队伍已经排的很长了。但是队伍消耗的也很快，等半个钟头就差不多可以上车了，不要去坐路边拉客的大巴。</p>
<p>华清池是历代皇帝的行宫，里面有各种温泉池，不得不感叹，这些人真是太会享受生活了。</p>
<p><img src="/image/xian/huaqingchi_1.jpg" alt="华清池"><br><img src="/image/xian/huaqingchi_2.jpg" alt="装逼"></p>
<p>兵马俑里面可以待一天，走路走到腿都要断掉了。推荐和其他人拼一个导游，自己到处看收货很少，虽然可以蹭导游，但是零零散散的很不完整，我们这次没有请导游有点遗憾。</p>
<p><img src="/image/xian/bingmayong.jpg" alt="兵马俑"></p>
<h3 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h3><p>第三天上午去了古城墙，可惜风太大，吹着有点冷，没多久女朋友有点不舒服就下去了。下午休息了一下午，晚上去看了音乐喷泉。</p>
<p><img src="/image/xian/guchengqiang_1.jpg" alt="西安古城墙"></p>
<p><img src="/image/xian/guchengqiang_2.jpg" alt="西安古城墙"></p>
<h3 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h3><p>第四天去了大小雁塔。</p>
<p>小雁塔很秀气，仰望去很有特色。<br><img src="/image/xian/xiaoyanta_2.jpg" alt="小雁塔"></p>
<p>大雁塔景区就比较大了，里面很多人工的景点，登顶后俯视西安城四面还是很不错的。<br><img src="/image/xian/dayanta_1.jpg" alt="大雁塔"><br><img src="/image/xian/dayanta_2.jpg" alt="大雁塔和音乐喷泉广场"><br><img src="/image/xian/dayanta_3.jpg" alt="大雁塔"></p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>这次西安之旅算是一个说走就走的旅行了，周二才决定出去玩，周四人就在西安了。那几天全国各处下雨，可供选择的目的地并不多。起初西安并不是首选，但四天下来，总的来说还是满意的。如果说有什么遗憾，那就是没有去成西安历史博物馆，第三天下午女朋友不舒服所以回宾馆休息了，第四天是周一，博物馆闭馆了。对西安这座城市，还是蛮喜欢的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年五一去的庐山，排队的惨烈还历历在目，于是今年就和女朋友决定五一不出去玩了。五一之前请了两天假加上周末，去西安玩了4天，五一就待在家里把游记补上。&lt;br&gt;
    
    </summary>
    
    
      <category term="travel" scheme="http://codersir.github.io/tags/travel/"/>
    
  </entry>
  
  <entry>
    <title>再探 JavaScript 中的作用域</title>
    <link href="http://codersir.github.io/2016/04/10/learn-javascript-scope-again/"/>
    <id>http://codersir.github.io/2016/04/10/learn-javascript-scope-again/</id>
    <published>2016-04-10T04:59:34.000Z</published>
    <updated>2016-07-21T12:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们常说，JS 是一门动态（类型）语言，但当我们讨论 JS 中的作用域的时候，大多数时候说的都是静态作用域，也叫<strong>词法作用域</strong>。作用域是和变量息息相关的，所以当我们谈变量的时候，提到的全局变量、局部变量这些术语，其实说的就是在不同范围（作用域）中的变量。<br><a id="more"></a></p>
<h2 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h2><p>作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。JS 中常见的作用域有：</p>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域</li>
<li>模块作用域（存在于 NodeJS 和 ES6 Module中）</li>
</ul>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>全局作用域的一种判定方式就是看它是否影响到整个程序。在浏览器中，全局作用域就是 <code>window</code> 对象。NodeJS 采用全局命名空间对象（<a href="https://nodejs.org/api/globals.html" target="_blank" rel="external">global</a>）来存放全局变量，但是需要注意的是，<code>global</code> 对象中存放却不一定都是全局变量，有些变量是属于模块的，比如 <code>__dirname</code>、<code>__filename</code>。</p>
<p>定义在全局作用域中的变量就是全局变量，全局变量在代码的各个位置都可以被访问，所以就可能会出现命名冲突，特别是在使用第三方脚本的时候。为了尽量避免暴露太多的全局变量到全局作用域，推荐使用命名空间或者模块化来解决这个问题。</p>
<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>函数作用域的含义是：在函数内定义的变量可以在整个函数范围内（包括嵌套的作用域中）使用。在函数外的作用域中是无法访问函数内部定义的变量很函数的。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">	<span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">1</span></div><div class="line">	function bar()&#123;</div><div class="line">		<span class="selector-tag">var</span> <span class="selector-tag">b</span> = <span class="number">2</span></div><div class="line">		console.log(a+b)</div><div class="line">	&#125;</div><div class="line">	bar()</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">foo</span><span class="params">()</span></span> <span class="comment">// 3</span></div><div class="line">console.log(a) <span class="comment">// ReferenceError: a is not defined</span></div></pre></td></tr></table></figure></p>
<p>通常，我们习惯的思维方式是：先定义一个函数，然后再在里面添加代码。但是反过来想，我们可以认为：从已有的代码中选择一些片段来进行封装，把它们放进一个函数作用域中“隐藏”起来。这种“隐藏”的思维是非常有用的，它能让我们规避命名冲突，同时符合最小暴露原则（再进一步其实就是模块的概念了）。同时，为了避免产生新的变量污染，一般采用立即执行函数表达式（IIFE）来“封闭”一个作用域。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">function</span> IIFE(<span class="name">global</span>, undefined)&#123;</div><div class="line">	// balabala</div><div class="line">&#125;)(<span class="name">window</span>)</div></pre></td></tr></table></figure>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>在 ES6 之前，我们通常会说 JS 是没有块级作用域的，最常用的一个例子就是 <code>for</code> 循环：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(i)	<span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<p>这段代码会输出 10 而不是 <code>undefined</code>，这就是由于缺少块级作用域导致的问题：我们原想定义在循环体内的变量在外部也可以访问。ES6 为了改变现状，新增了 <code>let</code> 用来解决这一问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(i)	<span class="comment">// ReferenceError: i is not defined</span></div></pre></td></tr></table></figure></p>
<p><code>var</code> 和 <code>let</code> 的另一个区别在于，<code>var</code> 和 <code>let</code> 声明的变量都会被提升到代码块的顶部，但 <code>var</code> 在声明前使用会得到 <code>undefined</code>，<code>let</code> 在声明前使用则会报<code>ReferenceError</code>的错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a)	<span class="comment">//undefined</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(b)	<span class="comment">//ReferenceError: b is not defined</span></div><div class="line"><span class="keyword">let</span> b = <span class="number">2</span></div></pre></td></tr></table></figure>
<p>同样会创建块级作用域的除了 <code>let</code> 还有 <code>const</code>，但它的值是固定的。</p>
<p>那么 ES6 之前的 JavaScript 是否真的没有块级作用域呢？其实还是有的。那就是 <code>try/catch</code> 代码块所创建的作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">	<span class="literal">undefined</span>()	<span class="comment">//TypeError: undefined is not a function(…)</span></div><div class="line">&#125; <span class="keyword">catch</span>(err)&#123;</div><div class="line">	<span class="built_in">console</span>.log(err)</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(err)	<span class="comment">//ReferenceError: err is not defined</span></div></pre></td></tr></table></figure>
<h3 id="模块作用域"><a href="#模块作用域" class="headerlink" title="模块作用域"></a>模块作用域</h3><p>模块作用域的含义是：在模块中定义的变量，只在这个模块范围内可以访问。在 ES6 之前，JavaScript 中并没有原生的模块的支持，所以模块作用域只对 NodeJS 有意义。ES6 引入了对模块的支持。</p>
<h3 id="其他作用域"><a href="#其他作用域" class="headerlink" title="其他作用域"></a>其他作用域</h3><p>和模块作用域类似的还有文件作用域，比如 C/C+++ 采用的就是文件作用域，定义在文件中的全局变量和全局函数都属于这个文件，在更高级的语言中，文件作用域被模块作用域所取代，比如 Python、NodeJS、ES6 module。</p>
<h2 id="词法作用域查找的特点"><a href="#词法作用域查找的特点" class="headerlink" title="词法作用域查找的特点"></a>词法作用域查找的特点</h2><ul>
<li>作用域会在找到第一个匹配的标识符时停止，在多层嵌套的作用域中可以定义同名的标识符，内部的标识符会“遮蔽”外部的标识符，这叫做“遮蔽效应”。</li>
<li>词法作用域只会查找一级标识符，比如 <code>foo.bar.baz</code>，词法作用域只会试图查找 <code>foo</code> 标识符，找到这个变量后，对象访问属性规则接管对 <code>bar</code> 和 <code>baz</code> 的访问。</li>
</ul>
<p>作用域是个很基础但是很重要的概念，所有的计算机语言都会花大量的篇幅来解释作用域，各个语言的作用域划分也都各有不同，这里我们对作用域的讨论只在 JavaScript 的范围之内。</p>
<p>动态类型的好处是书写简单，我们写 JS 的时候不需要定义类型或接口，也不需要担心把 string 变量赋值 boolean 会报错。但任何事物都是两面的，享受了书写代码时的便利，就要付出不便于调试和理解的代价。如果你对<br>“静态 JavaScript ”感兴趣的话，强烈推荐你试一试 TypeScript，可以参考我写的<a href="/2016/01/12/learn-typescript/">TypeScript 入门教程</a></p>
<h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Scope_(computer_science)" target="_blank" rel="external">Wikipedia scope</a></li>
<li><a href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html" target="_blank" rel="external">JavaScript Scoping and Hoisting</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们常说，JS 是一门动态（类型）语言，但当我们讨论 JS 中的作用域的时候，大多数时候说的都是静态作用域，也叫&lt;strong&gt;词法作用域&lt;/strong&gt;。作用域是和变量息息相关的，所以当我们谈变量的时候，提到的全局变量、局部变量这些术语，其实说的就是在不同范围（作用域）中的变量。&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://codersir.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>再探 JavaScript 中的 this</title>
    <link href="http://codersir.github.io/2016/04/10/learn-javascript-this-again/"/>
    <id>http://codersir.github.io/2016/04/10/learn-javascript-this-again/</id>
    <published>2016-04-10T04:55:20.000Z</published>
    <updated>2016-08-07T14:01:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 中的 <code>this</code> 关键字其实并不复杂，之所以需要再学一次是因为标准的推进，<code>this</code> 的值在不同的情况下表现的与之前有所不同。在 ES6 之前，我们谈 <code>this</code> 的时候，说的最多的就是 <code>this</code> 是动态作用域的。但随着 ES6 箭头函数的引入，现在也会经常看到大家说起 <em>词法作用域</em> 的 <code>this</code>。</p>
<a id="more"></a>
<h2 id="this-是什么？"><a href="#this-是什么？" class="headerlink" title="this 是什么？"></a><code>this</code> 是什么？</h2><p><code>this</code> 是一个<strong>关键字</strong>，ECMAScirpt 标准定义 <code>this</code> 为 <strong>ThisBindings 计算的值为当前执行上下文</strong>。</p>
<h2 id="词法作用域与“动态作用域”"><a href="#词法作用域与“动态作用域”" class="headerlink" title="词法作用域与“动态作用域”"></a>词法作用域与“动态作用域”</h2><p>我们都知道 ECMAScript 是没有动态作用域的，变量属于它定义时所在的作用域且不会发生改变。但是，大多数情况下，<code>this</code> 的值由函数<strong>调用时</strong>的上下文决定，也就是 <code>this</code> 表现的却像是“动态作用域”。它不能在函数运行前指定，而且可能因为每次调用的位置不同而不同。<code>this</code> 和作用域的关系，引用权威指南的原句：</p>
<blockquote>
<p>和变量不同，关键字 this 没有作用域限制，嵌套的函数不会从调用它的函数中继承 this。如果嵌套函数作为方法调用，其 <code>this</code> 值指向调用它的对象，如果嵌套函数作为函数调用，其 <code>this</code> 值不是全局对象（非严格模式下）就是 undefined（严格模式下）。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">9</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    count: <span class="number">0</span>,</div><div class="line">    plus: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// this 指向全局对象</span></div><div class="line">            <span class="keyword">this</span>.count++;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.count)</div><div class="line">        &#125;,<span class="number">0</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">obj.plus()  <span class="comment">//10</span></div></pre></td></tr></table></figure>
<p>解决这一问题的常见方法是定义一个变量 <code>self/that</code> 来保存当前的执行上下文：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">9</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    count: <span class="number">0</span>,</div><div class="line">    plus: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">var</span> <span class="keyword">self</span> = this</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">self</span>.count++;</div><div class="line">            console.log(<span class="keyword">self</span>.count)</div><div class="line">        &#125;,<span class="number">0</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">obj.plus()  <span class="comment">//1</span></div></pre></td></tr></table></figure>
<p>这样虽然解决了问题，但是却也容易带来困惑，人们容易记住使用这个方法就可以解决问题，却不去深究 <code>this</code> 的实现机制到底是怎样的，也不会去寻找更好的方法来解决这个问题：那就是词法作用域。</p>
<h2 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind 函数"></a><code>bind</code> 函数</h2><p>为了更好的解决上面的问题，回到 JavaScript 熟悉的词法作用域来，ES5 中引入了 <code>bind</code> 函数，<code>bind</code> 函数可以设置函数的 <code>this</code> 值而不管它如何调用，将 <code>this</code> 绑定到当前的词法作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">9</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    count: <span class="number">0</span>,</div><div class="line">    plus: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.count++;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.count)</div><div class="line">        &#125;.bind(<span class="keyword">this</span>),<span class="number">0</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">obj.plus() <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6 中新加入了对箭头函数的支持，<code>this</code> 指向定义时它的上下文且不会改变，遵循词法作用域规则。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var <span class="keyword">count</span> = <span class="number">9</span></div><div class="line">var obj = &#123;</div><div class="line">    <span class="keyword">count</span>: <span class="number">0</span>,</div><div class="line">    <span class="keyword">plus</span>() &#123;</div><div class="line">        setTimeout(() =&gt; &#123;</div><div class="line">            <span class="keyword">this</span>.<span class="keyword">count</span>++;</div><div class="line">            console.log(<span class="keyword">this</span>.<span class="keyword">count</span>)</div><div class="line">        &#125;,<span class="number">0</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">obj.<span class="keyword">plus</span>()  <span class="comment">//1</span></div></pre></td></tr></table></figure>
<p>之所以这样，背后真正的原因是：<strong>箭头函数没有自己的 <code>this</code>，箭头函数的 <code>this</code> 是从包裹它的作用域继承过来的</strong>。</p>
<p>所以，在 ES6 后，你几乎不需要再提心吊胆担心掉进 <code>this</code> 的坑里，只要你遵循下面两条规则：</p>
<ul>
<li>对方法都使用 <strong>非</strong> 箭头函数</li>
<li>其他的地方都使用箭头函数</li>
</ul>
<h2 id="call-…-和-apply-…"><a href="#call-…-和-apply-…" class="headerlink" title="call(…) 和 apply(…)"></a>call(…) 和 apply(…)</h2><p>JavaScript 中除了 <code>bind</code> 函数可以手动绑定 <code>this</code> 以外，还提供了 <code>call</code> 和 <code>apply</code> 函数用来在调用函数的时候，手动改变函数调用上下文。<code>call</code> 和 <code>apply</code> 函数的第一个参数就是本次调用的上下文：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">9</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    count: <span class="number">0</span>,</div><div class="line">    plus: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.count++;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.count)</div><div class="line">        &#125;.bind(<span class="keyword">this</span>),<span class="number">0</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">obj.plus() <span class="comment">// 1</span></div><div class="line">obj.plus.apply(<span class="keyword">this</span>) <span class="comment">// 10</span></div></pre></td></tr></table></figure>
<h2 id="new-构造函数"><a href="#new-构造函数" class="headerlink" title="new 构造函数"></a><code>new</code> 构造函数</h2><p>当通过 <code>new</code> 操作符创建对象时，JavaScript 编译器会先创建一个新的空对象，然后设置一些内部的属性，并调用新对象的构造函数。因此，当通过 <code>new</code> 调用构造函数时，<code>this</code> 指向这个新创建的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> F = ()=&gt;&#123;</div><div class="line">  <span class="keyword">this</span>.a = <span class="number">1</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">F() <span class="comment">// Window</span></div><div class="line"><span class="keyword">new</span> F() <span class="comment">// &#123;a:1&#125;</span></div></pre></td></tr></table></figure>
<h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a><code>eval</code></h2><p>直接调用 <code>eval</code>，<code>this</code> 和 <code>eval()</code> 执行环境中的 <code>this</code> 保持一致。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">eval</span>(<span class="string">'this===window'</span>) <span class="comment">// true</span></div><div class="line"><span class="keyword">use</span> <span class="title">strict</span>; <span class="comment">// 严格模式下</span></div><div class="line"><span class="keyword">eval</span>(<span class="string">'this===undefined'</span>) <span class="comment">// true</span></div><div class="line"><span class="comment">// 方法中</span></div><div class="line"><span class="keyword">var</span> obj = &#123;  </div><div class="line">  method: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">    console.log(<span class="keyword">eval</span>(<span class="string">'this'</span>) === obj)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">obj.method() <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="class-类里面的-this"><a href="#class-类里面的-this" class="headerlink" title="class 类里面的 this"></a><code>class</code> 类里面的 <code>this</code></h2><p>类会在调用 constructor 函数的时候初始化 <code>this</code>，子类 constructor 函数中在调用 <code>super()</code> 以后才能使用 <code>this</code>，否则会报 <code>ReferenceError: this is not defined</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面基本上列出了 JavaScript 中与 <code>this</code> 相关的方方面面了，掌握 <code>this</code> 并不难，随着 ES6 的推进，善用箭头函数，掉进坑的机会就更少了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work" target="_blank" rel="external">stackoverflow: How does the “this” keyword work?</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="external">MDN this</a></li>
<li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/apC.md" target="_blank" rel="external">You-Dont-Know-This</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 中的 &lt;code&gt;this&lt;/code&gt; 关键字其实并不复杂，之所以需要再学一次是因为标准的推进，&lt;code&gt;this&lt;/code&gt; 的值在不同的情况下表现的与之前有所不同。在 ES6 之前，我们谈 &lt;code&gt;this&lt;/code&gt; 的时候，说的最多的就是 &lt;code&gt;this&lt;/code&gt; 是动态作用域的。但随着 ES6 箭头函数的引入，现在也会经常看到大家说起 &lt;em&gt;词法作用域&lt;/em&gt; 的 &lt;code&gt;this&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://codersir.github.io/tags/JavaScript/"/>
    
      <category term="ecma" scheme="http://codersir.github.io/tags/ecma/"/>
    
  </entry>
  
  <entry>
    <title>理解 Zone 的实现机制</title>
    <link href="http://codersir.github.io/2016/03/13/dive-into-zone/"/>
    <id>http://codersir.github.io/2016/03/13/dive-into-zone/</id>
    <published>2016-03-13T13:02:10.000Z</published>
    <updated>2016-06-18T19:00:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>Zone 是一种用来拦截和追踪异步任务的机制。</p>
<p>Zone 可以做以下事情：</p>
<ol>
<li>拦截异步任务调度</li>
<li>包装异步操作的错误处理和 zone 追踪的回调函数</li>
<li>提供一种办法添加数据到 zones</li>
<li>提供最后一帧错误处理的具体上下文</li>
<li>拦截阻塞方法</li>
</ol>
<h2 id="zone-的原理"><a href="#zone-的原理" class="headerlink" title="zone 的原理"></a>zone 的原理</h2><p>zone 本身并不做任何事情，它依赖其他代码让平台API穿过它。</p>
<p>最简单的形式是，zone 通过 patch 异步API，允许我们拦截异步操作的调用和调度，并且在异步任务之前和之后执行额外的代码。</p>
<p>拦截规则通过 ZoneConfig 来配置。</p>
<p>一个系统中可以同时存在多个 zone 的实例，但是在任意时刻都只有一个处于激活状态，可以通过 <code>Zone.current</code> 获取到。</p>
<h3 id="包装回调函数"><a href="#包装回调函数" class="headerlink" title="包装回调函数"></a>包装回调函数</h3><p>zone 的一个重要部分就是在异步操作的过程中保持一致。为了做到这一点，当一个未来任务通过异步API被调用的时候，需要捕获并随后重现当前 zone。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> oldZone = _currentZone</div><div class="line">currentZone = <span class="keyword">this</span></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">  <span class="comment">// do stuff ...</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  _currentZone = oldZone</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你把异步操作当做线程执行来看，那么当前 Zone 就是线程局部变量。</p>
<h3 id="异步操作调度"><a href="#异步操作调度" class="headerlink" title="异步操作调度"></a>异步操作调度</h3><p>基本上有三种类型的任务可以被调度,每个异步 API 都通过以下 API 来建模和路由：</p>
<ol>
<li>在当前任务之后立即执行的 MicroTask，不可取消</li>
<li>稍后执行的 TimerTask，可以取消，通常包括这些方法： <code>setTimeout</code>, <code>setImmediate</code>, <code>setInterval</code>, <code>requestAnimationFrame</code> 等</li>
<li>用来监听未来事件的 EventTask，可能多次执行</li>
</ol>
<h3 id="组合性"><a href="#组合性" class="headerlink" title="组合性"></a>组合性</h3><p>Zones 可以通过 <code>Zone.fork()</code> 方法组合在一起。子 zone 可以创建它自己规则，一个子 zone ：</p>
<ol>
<li>通过父 zone 代理拦截，并且可选地在包装回调之前和之后添加钩子</li>
<li>或不用代理自己处理请求</li>
</ol>
<p>组合性让 zones 可以彼此保持独立不干扰。比如顶层 zone 可以选择处理错误，但子 zone 可以追踪用户行为。</p>
<h3 id="根-zone"><a href="#根-zone" class="headerlink" title="根 zone"></a>根 zone</h3><p>浏览器在开始的时候会创建一个特殊的根 zone，所有的 zone 都是根 zone 的子 zone。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Zone-fork-ZoneSpec"><a href="#Zone-fork-ZoneSpec" class="headerlink" title="Zone.fork(ZoneSpec)"></a><code>Zone.fork(ZoneSpec)</code></h3><p>复制一个子 zone，传入子 zone 的配置规则，通常是一系列的生命钩子：</p>
<ul>
<li><code>onFork</code>，拦截 zone 的复制</li>
<li><code>onIntercept</code>，拦截回调函数的包装</li>
<li><code>onInvoke</code>，拦截回调函数的调用</li>
<li><code>onHandleError</code>，拦截错误处理</li>
<li><code>onScheduleTask</code>，拦截任务调度</li>
<li><code>onInvokeTask</code>，拦截任务执行</li>
<li><code>onCancelTask</code>，拦截任务取消</li>
<li><code>onHasTask</code>，任务队列状态变化通知</li>
</ul>
<p>通过 <code>properties</code> 参数，还可以给子 zone 传入其他的属性，通过 <code>zone.get</code> 方法获取这些属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  Zone.current.get(<span class="string">'reset'</span>)()</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Timeout callback called after '</span> + Zone.current.get(<span class="string">'time'</span>)())</div><div class="line">  &#125;, <span class="number">1000</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> mySpec = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> time = <span class="number">0</span>, start = <span class="number">0</span></div><div class="line">  <span class="keyword">var</span> timer = performance ?</div><div class="line">                performance.now.bind(performance) :</div><div class="line">                <span class="built_in">Date</span>.now.bind(<span class="built_in">Date</span>)</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    onScheduleTask: <span class="function"><span class="keyword">function</span>(<span class="params">delegate, current, target, task</span>)</span>&#123;</div><div class="line">      start = timer()</div><div class="line">      delegate.scheduleTask(target, task)</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'scheduling '</span> + task.source + <span class="string">' =&gt; '</span> + task.data.handleId)</div><div class="line">    &#125;,</div><div class="line">    onInvokeTask: <span class="function"><span class="keyword">function</span>(<span class="params">delegate, current, target, task</span>)</span>&#123;</div><div class="line">      delegate.invokeTask(target, task)</div><div class="line">      time += timer() - start</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Invoking '</span> + task.source + <span class="string">' =&gt; '</span> + task.data.handleId + <span class="string">' after '</span> + time + <span class="string">' ms'</span>)</div><div class="line">    &#125;,</div><div class="line">    properties: &#123;</div><div class="line">      reset: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        time = <span class="number">0</span></div><div class="line">        start = <span class="number">0</span></div><div class="line">      &#125;,</div><div class="line">      time: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> timer() - start + <span class="string">' ms'</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)()</div><div class="line"></div><div class="line">Zone.current.fork(mySpec).run(main)</div></pre></td></tr></table></figure>
<h3 id="Zone-wrap"><a href="#Zone-wrap" class="headerlink" title="Zone.wrap"></a><code>Zone.wrap</code></h3><p>包装回调函数使之在调用过程中可以正确的恢复当前 zone。在函数被包装起来之前，可以通过配置 <code>ZoneSpec.onIntercept</code> 来进行拦截。</p>
<h3 id="Zone-run"><a href="#Zone-run" class="headerlink" title="Zone.run"></a><code>Zone.run</code></h3><p>在指定的 zone 中调用函数，返回回调函数执行后的返回值。在回调函数被调用之前可以通过配置 <code>ZoneSpec.onInvoke</code> 来进行拦截。</p>
<h3 id="Zone-runGuarded"><a href="#Zone-runGuarded" class="headerlink" title="Zone.runGuarded"></a><code>Zone.runGuarded</code></h3><p><code>Zone.run</code> + 错误处理，任何的错误都会被转到 <code>ZoneDelegate.HandleError</code>。错误在处理之前可以通过配置 <code>ZoneSpec.onHandleError</code> 来进行拦截。</p>
<h3 id="Zone-runTask"><a href="#Zone-runTask" class="headerlink" title="Zone.runTask"></a><code>Zone.runTask</code></h3><p>在任务的 zone 中恢复当前 zone 后执行任务。任务在执行之前，可以通过配置 <code>Zone.onInvokeTask</code> 来进行拦截。</p>
<h3 id="Zone-scheduleMicroTask-Zone-scheduleMacroTask-Zone-scheduleEventTask"><a href="#Zone-scheduleMicroTask-Zone-scheduleMacroTask-Zone-scheduleEventTask" class="headerlink" title="Zone.scheduleMicroTask Zone.scheduleMacroTask Zone.scheduleEventTask"></a><code>Zone.scheduleMicroTask</code> <code>Zone.scheduleMacroTask</code> <code>Zone.scheduleEventTask</code></h3><p>安排不同类型的任务，通过 <code>ZoneSpec.onScheduleTask</code> 来进行拦截。</p>
<h3 id="Zone-cancelTask"><a href="#Zone-cancelTask" class="headerlink" title="Zone.cancelTask"></a><code>Zone.cancelTask</code></h3><p>拦截已安排任务的取消，任务取消之前可以通过 <code>ZoneSpec.onCancelTask</code> 来进行拦截，默认情况下任务取消会调用 <code>Task.cancelFn</code>。</p>
<h2 id="NgZone-in-Angular2"><a href="#NgZone-in-Angular2" class="headerlink" title="NgZone in Angular2"></a>NgZone in Angular2</h2><p>Angular2 通过 <strong>变化检测</strong> 来更新视图，那么谁来告诉 Angular2 有状态发生了改变呢？那就是 NgZone。在 Angular2 中，将不再需要不停的进行脏检查来保持视图和状态的同步，当有状态发生变化时，NgZone 的事件钩子会通知 Angular 来更新视图。Angular2 的 ZoneSpec 如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    name: <span class="string">'angular'</span>,</div><div class="line">    properties:<span class="xml"><span class="tag">&lt;<span class="name">any</span>&gt;</span>&#123;'isAngularZone': true&#125;,</span></div><div class="line">    onInvokeTask: (delegate: ZoneDelegate, current: Zone, target: Zone, task: Task,</div><div class="line">                   applyThis: any, applyArgs: any): any =&gt; &#123;</div><div class="line">      try &#123;</div><div class="line">        this.onEnter();</div><div class="line">        return delegate.invokeTask(target, task, applyThis, applyArgs);</div><div class="line">      &#125; finally &#123;</div><div class="line">        this.onLeave();</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    onInvoke: (delegate: ZoneDelegate, current: Zone, target: Zone, callback: Function,</div><div class="line">               applyThis: any, applyArgs: any[], source: string): any =&gt; &#123;</div><div class="line">      try &#123;</div><div class="line">        this.onEnter();</div><div class="line">        return delegate.invoke(target, callback, applyThis, applyArgs, source);</div><div class="line">      &#125; finally &#123;</div><div class="line">        this.onLeave();</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    onHasTask:(delegate: ZoneDelegate, current: Zone, target: Zone, hasTaskState: HasTaskState) =&gt; &#123;</div><div class="line">        delegate.hasTask(target, hasTaskState);</div><div class="line">        if (current == target) &#123;</div><div class="line">          // We are only interested in hasTask events which originate from our zone</div><div class="line">          // (A child hasTask event is not interesting to us)</div><div class="line">          if (hasTaskState.change == 'microTask') &#123;</div><div class="line">            this.setMicrotask(hasTaskState.microTask);</div><div class="line">          &#125; else if (hasTaskState.change == 'macroTask') &#123;</div><div class="line">            this.setMacrotask(hasTaskState.macroTask);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    onHandleError: (delegate: ZoneDelegate, current: Zone, target: Zone, error: any): boolean =&gt; &#123;</div><div class="line">       delegate.handleError(target, error);</div><div class="line">       this.onError(new NgZoneError(error, error.stack));</div><div class="line">       return false;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>onEnter</code> 和 <code>onLeave</code> 就是相应事件的回调函数。</p>
<p>下面这些情况会被 Angular2 判断为有状态发生了改变：</p>
<ul>
<li>用户行为</li>
<li>http 返回</li>
<li>定时器，<code>setTimeout</code>,<code>setInterval</code></li>
</ul>
<p>Zone 为这些事件都添加了钩子，用来通知 Angular 再完美不过了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/angular/zone.js" target="_blank" rel="external">zone.js</a></li>
<li><a href="https://github.com/angular/angular" target="_blank" rel="external">angular</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Zone 是一种用来拦截和追踪异步任务的机制。&lt;/p&gt;
&lt;p&gt;Zone 可以做以下事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拦截异步任务调度&lt;/li&gt;
&lt;li&gt;包装异步操作的错误处理和 zone 追踪的回调函数&lt;/li&gt;
&lt;li&gt;提供一种办法添加数据到 zones&lt;/li&gt;
&lt;li
    
    </summary>
    
    
      <category term="angular2" scheme="http://codersir.github.io/tags/angular2/"/>
    
      <category term="zone" scheme="http://codersir.github.io/tags/zone/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的装饰器是什么？</title>
    <link href="http://codersir.github.io/2016/01/31/what-is-decorator-in-javascript/"/>
    <id>http://codersir.github.io/2016/01/31/what-is-decorator-in-javascript/</id>
    <published>2016-01-30T16:36:01.000Z</published>
    <updated>2016-05-29T18:17:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>装饰器是 ES7（也就是ES2016）的提案，虽然听着感觉好像还有点遥远，毕竟 ES6 还没有走多久呢，但实际上，2016年已经到来，也就是说，ES7 的提案今年就会成为新的标准，同时借助一些编译器（比如babel），我们早已经可以在正式环境中使用它了。另外，TypeScript 在去年和<br>AtScript 合并后发布的 1.5 版本，就已经支持装饰器语法了。基于 TypeScript 开发的 Angular2 里面也大量的使用了装饰器。</p>
<h2 id="什么是装饰器"><a href="#什么是装饰器" class="headerlink" title="什么是装饰器"></a>什么是装饰器</h2><p>用提案的描述来说，装饰器是：</p>
<blockquote>
<p>一个求值结果为函数的表达式，接受目标对象、名称和装饰器描述作为参数，可选地返回一个装饰器描述来安装到目标对象上。</p>
</blockquote>
<a id="more"></a>
<h2 id="怎么使用装饰器"><a href="#怎么使用装饰器" class="headerlink" title="怎么使用装饰器"></a>怎么使用装饰器</h2><p>TypeScript 已经完整的支持了 ES7 装饰器的接口，通过 <a href="https://github.com/Microsoft/TypeScript/blob/master/src/lib/core.d.ts#L1254" target="_blank" rel="external">TypeScript 装饰器的实现</a>，来进一步掌握装饰器的使用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">declare</span> <span class="keyword">type</span> ClassDecorator = &lt;TFunction extends <span class="keyword">Function</span>&gt;(target: TFunction) =&gt; TFunction | <span class="built_in">void</span>;</div><div class="line"><span class="keyword">declare</span> <span class="keyword">type</span> PropertyDecorator = (target: <span class="keyword">Object</span>, propertyKey: <span class="keyword">string</span> | symbol) =&gt; <span class="built_in">void</span>;</div><div class="line"><span class="keyword">declare</span> <span class="keyword">type</span> MethodDecorator = &lt;T&gt;(target: <span class="keyword">Object</span>, propertyKey: <span class="keyword">string</span> | symbol, <span class="keyword">descriptor</span>: TypedPropertyDescriptor&lt;T&gt;) =&gt; TypedPropertyDescriptor&lt;T&gt; | <span class="built_in">void</span>;</div><div class="line"><span class="keyword">declare</span> <span class="keyword">type</span> ParameterDecorator = (target: <span class="keyword">Object</span>, propertyKey: <span class="keyword">string</span> | symbol, parameterIndex: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span>;</div></pre></td></tr></table></figure>
<p>通过上面的代码可以知道，装饰器可以用来注解<strong>类</strong>，<strong>属性</strong>，<strong>方法</strong>和<strong>参数</strong>，下面分别看不同情况下如何使用和实现。</p>
<h3 id="装饰类"><a href="#装饰类" class="headerlink" title="装饰类"></a>装饰类</h3><p>TypeScript 类装饰器接口如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">declare <span class="keyword">type</span> ClassDecorator = &lt;TFunction <span class="keyword">extends</span> <span class="function"><span class="keyword">Function</span></span>&gt;(<span class="keyword">target</span>: TFunction) =&gt; TFunction | void;</div></pre></td></tr></table></figure>
<p>通过接口可以知道类装饰器接受一个目标函数作为参数，考虑下面简单的类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> name: string</div><div class="line">    <span class="keyword">public</span> power: string</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(name: string, power: string) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name</div><div class="line">        <span class="keyword">this</span>.power = power</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    showPower()&#123;</div><div class="line">    	<span class="keyword">return</span> `$&#123;<span class="keyword">this</span>.name&#125; has special power: $&#123;<span class="keyword">this</span>.power&#125;`</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把上面的代码编译为 JavaScript，得到：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Hero = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Hero</span><span class="params">(name, power)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.power = power;</div><div class="line">    &#125;</div><div class="line">    Hero.prototype.showPower = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">" has special power: "</span> + <span class="keyword">this</span>.power;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> Hero;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>下面给 <code>Hero</code> 类添加一个 <code>@logClass</code> 的装饰器：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@logClass</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> name: string</div><div class="line">    <span class="keyword">public</span> power: string</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(name: string, power: string) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name</div><div class="line">        <span class="keyword">this</span>.power = power</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    showPower()&#123;</div><div class="line">    	<span class="keyword">return</span> `$&#123;<span class="keyword">this</span>.name&#125; has special power: $&#123;<span class="keyword">this</span>.power&#125;`</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重新编译成 JavaScript ：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Hero = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Hero</span><span class="params">(name, power)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.power = power;</div><div class="line">    &#125;</div><div class="line">    Hero.prototype.showPower = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">" has "</span> + <span class="keyword">this</span>.power;</div><div class="line">    &#125;;</div><div class="line">    Hero = __decorate([</div><div class="line">        logClass</div><div class="line">    ], Hero);</div><div class="line">    <span class="keyword">return</span> Hero;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>上面的代码在返回<code>Hero</code>构造函数之前，将它作为参数传给了<code>__decorate</code>函数，那<code>__decorate</code>函数做了什么？看编译后的 JavaScript 代码，可以看到该函数实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 保证上下文中只有一个 __decorate 函数，不会被反复重载</span></div><div class="line"><span class="keyword">var</span> __decorate = (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.__decorate) || <span class="function"><span class="keyword">function</span>(<span class="params">decorators, target, key, desc</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> c = <span class="built_in">arguments</span>.length,</div><div class="line">    	<span class="comment">// 装饰类的时候，__decorate 函数接受两个参数，所以 r = target，也就是上文的构造函数 Hero</span></div><div class="line">        r = c &lt; <span class="number">3</span> ? target : desc === <span class="literal">null</span> ? desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key) : desc,</div><div class="line">        d;</div><div class="line">    <span class="comment">// 这是另外一个 ES7 API 了，先不管，看 fallback 方案</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Reflect</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Reflect</span>.decorate === <span class="string">"function"</span>) r = <span class="built_in">Reflect</span>.decorate(decorators, target, key, desc);</div><div class="line">    <span class="keyword">else</span></div><div class="line">    	<span class="comment">// 从右向左依次执行 decorator 函数，对 class 而言，相当于 decorators.reduceRight(function(o, d)&#123; return (d &amp;&amp; d(r)) || o &#125;, r)</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = decorators.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">            <span class="keyword">if</span> (d = decorators[i]) r = (c &lt; <span class="number">3</span> ? d(r) : c &gt; <span class="number">3</span> ? d(target, key, r) : d(target, key)) || r;</div><div class="line">    最后返回 r</div><div class="line">    <span class="keyword">return</span> c &gt; <span class="number">3</span> &amp;&amp; r &amp;&amp; <span class="built_in">Object</span>.defineProperty(target, key, r), r;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>__decorate</code> 函数体其实很简单，主要是进行一些条件判断，根据传入参数个数的不同判断装饰器的类型，并执行相关的装饰器函数。</p>
<p>需要注意的两个函数是：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" target="_blank" rel="external">Object.getOwnPropertyDescriptor</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">Object.defineProperty</a><br>第一个函数是获取对象自有属性的描述符，第二是添加或修改对象的自有属性，具体用法查看 MDN。</li>
</ul>
<p>知道装饰器装饰类是如何进行工作后，下面来完善 <code>@logClass</code> 装饰器。通过类装饰器接口可以知道，它接受一个函数作为参数，并返回函数。 <code>@logClass</code> 装饰器的目的是，在每次英雄被派出去拯救世界的时候，<br>记录下来是哪个英雄出去了，为他祈祷，实现如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logClass</span><span class="params">(target: any)</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 保存原始构造器</span></div><div class="line">  <span class="keyword">var</span> original = target;</div><div class="line"></div><div class="line">  <span class="comment">// 工具函数，生成类的实例</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">construct</span><span class="params">(constructor, args)</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> c : any = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> constructor.apply(<span class="keyword">this</span>, args);</div><div class="line">    &#125;</div><div class="line">    c.prototype = constructor.prototype;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> c();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 添加行为到构造器调用时</span></div><div class="line">  <span class="keyword">var</span> f : any = <span class="function"><span class="keyword">function</span> <span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</div><div class="line">    console.log(<span class="string">"God bless "</span> + args[<span class="number">0</span>]); </div><div class="line">    <span class="keyword">return</span> construct(original, args);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 复制原始构造器的原型</span></div><div class="line">  f.prototype = original.prototype;</div><div class="line"></div><div class="line">  <span class="comment">// 返回新的构造器</span></div><div class="line">  <span class="keyword">return</span> f;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码已经清晰的注释了，就不添加更多的说明了，可以看到，类装饰器就是<strong>给构造函数添加额外的动作</strong>。现在当派出一个新的英雄之前，我们会为他祈福：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> batman = <span class="keyword">new</span> Hero(<span class="string">'batman'</span>, <span class="string">'fly'</span>)</div><div class="line"><span class="comment">// God bless batman</span></div><div class="line"></div><div class="line">batman <span class="keyword">instanceof</span> Hero</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><a href="http://www.typescriptlang.org/Playground#src=%40logClass%0D%0Aclass%20Hero%20%7B%0D%0A%20%20%20%20public%20name%3A%20string%3B%0D%0A%20%20%20%20public%20power%3A%20string%3B%0D%0A%0D%0A%20%20%20%20constructor(name%3A%20string%2C%20power%3A%20string)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.name%20%3D%20name%0D%0A%20%20%20%20%20%20%20%20this.power%20%3D%20power%0D%0A%20%20%20%20%7D%0D%0A%0D%0A%20%20%20%20showPower()%7B%0D%0A%20%20%20%20%09return%20%60%24%7Bthis.name%7D%20has%20special%20power%3A%20%24%7Bthis.power%7D%60%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Afunction%20logClass(target%3A%20any)%20%7B%0D%0A%0D%0A%20%20%2F%2F%20%E4%BF%9D%E5%AD%98%E5%8E%9F%E5%A7%8B%E6%9E%84%E9%80%A0%E5%99%A8%0D%0A%20%20var%20original%20%3D%20target%3B%0D%0A%0D%0A%20%20%2F%2F%20%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%EF%BC%8C%E7%94%9F%E6%88%90%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%0D%0A%20%20function%20construct(constructor%2C%20args)%20%7B%0D%0A%20%20%20%20var%20c%20%3A%20any%20%3D%20function%20()%20%7B%0D%0A%20%20%20%20%20%20return%20constructor.apply(this%2C%20args)%3B%0D%0A%20%20%20%20%7D%0D%0A%20%20%20%20c.prototype%20%3D%20constructor.prototype%3B%0D%0A%20%20%20%20return%20new%20c()%3B%0D%0A%20%20%7D%0D%0A%0D%0A%20%20%2F%2F%20%E6%B7%BB%E5%8A%A0%E8%A1%8C%E4%B8%BA%E5%88%B0%E6%9E%84%E9%80%A0%E5%99%A8%E8%B0%83%E7%94%A8%E6%97%B6%0D%0A%20%20var%20f%20%3A%20any%20%3D%20function%20(...args)%20%7B%0D%0A%20%20%20%20console.log(%22God%20bless%20%22%20%2B%20args%5B0%5D)%3B%20%0D%0A%20%20%20%20return%20construct(original%2C%20args)%3B%0D%0A%20%20%7D%0D%0A%0D%0A%20%20%2F%2F%20%E5%A4%8D%E5%88%B6%E5%8E%9F%E5%A7%8B%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E5%8E%9F%E5%9E%8B%0D%0A%20%20f.prototype%20%3D%20original.prototype%3B%0D%0A%0D%0A%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E6%96%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%0D%0A%20%20return%20f%3B%0D%0A%7D%0D%0Anew%20Hero('batman'%2C%20'fly')" target="_blank" rel="external">play</a></p>
<h3 id="装饰属性"><a href="#装饰属性" class="headerlink" title="装饰属性"></a>装饰属性</h3><p>TypeScript 属性装饰器接口如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">declare</span> <span class="keyword">type</span> PropertyDecorator = (target: <span class="keyword">Object</span>, propertyKey: <span class="keyword">string</span> | symbol) =&gt; <span class="built_in">void</span>;</div></pre></td></tr></table></figure>
<p>由接口可以知道，属性装饰器接受两个参数，一个是目标对象，另一个是属性名称，没有返回值。<br>继续使用上面 Hero 类，这次给 <code>power</code> 属性加上 <code>@logProperty</code> 属性装饰器，在给英雄使用超能力的时候，添加 Bgm，代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> name: string</div><div class="line">    <span class="meta">@logProperty</span></div><div class="line">    <span class="keyword">public</span> power: string</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(name:string, power:string)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name</div><div class="line">        <span class="keyword">this</span>.power = power</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    showPower()&#123;</div><div class="line">        <span class="keyword">return</span> `$&#123;<span class="keyword">this</span>.name&#125; has special power: $&#123;<span class="keyword">this</span>.power&#125;`</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，编译成 JavaScript 后得到：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Hero = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Hero</span><span class="params">(name, power)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.power = power;</div><div class="line">    &#125;</div><div class="line">    Hero.prototype.showPower = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">" has special power: "</span> + <span class="keyword">this</span>.power;</div><div class="line">    &#125;;</div><div class="line">    __decorate([</div><div class="line">        logProperty</div><div class="line">    ], Hero.prototype, <span class="string">"power"</span>, <span class="keyword">void</span> <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> Hero;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>此处再次用到了 <code>__decorate</code> 函数，但传入参数的个数是3个，装饰器，构造函数的原型和属性名，所以精简一下 <code>__decorator</code> 函数，得到属性装饰器的版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> __decorate = (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.__decorate) || <span class="function"><span class="keyword">function</span>(<span class="params">decorators, target, key, desc</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> c = <span class="built_in">arguments</span>.length,</div><div class="line">    	r = <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key)</div><div class="line">        d;</div><div class="line">    <span class="comment">// 从右向左依次执行 decorator 函数，相当于 decorators.reduceRight(function(o, d)&#123; return (d &amp;&amp; d(target, key) || o &#125;, r)</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = decorators.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">        <span class="keyword">if</span> (d = decorators[i]) r = d(target, key) || r;</div><div class="line">    <span class="keyword">return</span> r;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>另外对比类装饰器，可以看到这次没有用 <code>__decorate</code> 函数的返回值覆盖原始的类，属性装饰器的接口是没有返回值（=&gt;void)的。</p>
<p>现在知道了属性装饰器接受构造器的原型和属性名作为参数，并且没有返回值，下面开始着手实现 <code>@logProperty</code> 装饰器：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProperty</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 存储属性值</span></div><div class="line">  <span class="keyword">var</span> _val = <span class="keyword">this</span>[key];</div><div class="line"></div><div class="line">  <span class="comment">// 获取属性</span></div><div class="line">  <span class="keyword">var</span> getter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`此处应有 Bgm <span class="subst">$&#123;_val&#125;</span>`</span>);</div><div class="line">    <span class="keyword">return</span> _val;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">// 设置属性</span></div><div class="line">  <span class="keyword">var</span> setter = <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`切换特技 <span class="subst">$&#123;newVal&#125;</span>`</span>);</div><div class="line">    _val = newVal;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">// 删除属性并重新设置该属性</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">delete</span> <span class="keyword">this</span>[key]) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个新的属性，使用我们自定义的存储器</span></div><div class="line">    <span class="built_in">Object</span>.defineProperty(target, key, &#123;</div><div class="line">      <span class="keyword">get</span>: getter,</div><div class="line">      <span class="keyword">set</span>: setter,</div><div class="line">      enumerable: <span class="literal">true</span>,</div><div class="line">      configurable: <span class="literal">true</span></div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>// todo<br>// this在此处的使用需要进一步说明，为什么 this 的上下文是构造器原型？</p>
<p>现在，英雄放大招和切换大招的时候，我们就会看到控制台输出了：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> batman = new Hero(<span class="string">'batman'</span>, <span class="string">'fly'</span>)</div><div class="line"><span class="comment">// 切换特技 fly</span></div><div class="line">batman.showPower()</div><div class="line"><span class="comment">// 此处应有 Bgm</span></div><div class="line">batman<span class="selector-class">.power</span> = <span class="string">'doublekill'</span></div><div class="line"><span class="comment">// 切换特技 doublekill</span></div></pre></td></tr></table></figure>
<p><a href="http://www.typescriptlang.org/Playground#src=class%20Hero%20%7B%0D%0A%20%20%20%20public%20name%3A%20string%0D%0A%20%20%20%20%40logProperty%0D%0A%20%20%20%20public%20power%3A%20string%0D%0A%0D%0A%20%20%20%20constructor(name%3Astring%2C%20power%3Astring)%7B%0D%0A%20%20%20%20%20%20%20%20this.name%20%3D%20name%0D%0A%20%20%20%20%20%20%20%20this.power%20%3D%20power%0D%0A%20%20%20%20%7D%0D%0A%0D%0A%20%20%20%20showPower()%7B%0D%0A%20%20%20%20%20%20%20%20return%20%60%24%7Bthis.name%7D%20has%20special%20power%3A%20%24%7Bthis.power%7D%60%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Afunction%20logProperty(target%3A%20any%2C%20key%3A%20string)%20%7B%0D%0A%0D%0A%20%20%2F%2F%20%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7%E5%80%BC%0D%0A%20%20var%20_val%20%3D%20this%5Bkey%5D%3B%0D%0A%0D%0A%20%20%2F%2F%20%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%0D%0A%20%20var%20getter%20%3D%20function%20()%20%7B%0D%0A%20%20%20%20console.log(%60%E6%AD%A4%E5%A4%84%E5%BA%94%E6%9C%89%20Bgm%20%24%7B_val%7D%60)%3B%0D%0A%20%20%20%20return%20_val%3B%0D%0A%20%20%7D%3B%0D%0A%0D%0A%20%20%2F%2F%20%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%0D%0A%20%20var%20setter%20%3D%20function%20(newVal)%20%7B%0D%0A%20%20%20%20console.log(%60%E5%88%87%E6%8D%A2%E7%89%B9%E6%8A%80%20%24%7BnewVal%7D%60)%3B%0D%0A%20%20%20%20_val%20%3D%20newVal%3B%0D%0A%20%20%7D%3B%0D%0A%0D%0A%20%20%2F%2F%20%E5%88%A0%E9%99%A4%E5%B1%9E%E6%80%A7%E5%B9%B6%E9%87%8D%E6%96%B0%E8%AE%BE%E7%BD%AE%E8%AF%A5%E5%B1%9E%E6%80%A7%0D%0A%20%20if%20(delete%20this%5Bkey%5D)%20%7B%0D%0A%0D%0A%20%20%20%20%2F%2F%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%88%91%E4%BB%AC%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%0D%0A%20%20%20%20Object.defineProperty(target%2C%20key%2C%20%7B%0D%0A%20%20%20%20%20%20get%3A%20getter%2C%0D%0A%20%20%20%20%20%20set%3A%20setter%2C%0D%0A%20%20%20%20%20%20enumerable%3A%20true%2C%0D%0A%20%20%20%20%20%20configurable%3A%20true%0D%0A%20%20%20%20%7D)%3B%0D%0A%20%20%7D%0D%0A%7D%0D%0A%0D%0Avar%20hero%20%3D%20new%20Hero('batman'%2C'fly')%0D%0Ahero.showPower()%0D%0Ahero.power%20%3D%20'doublekill'" target="_blank" rel="external">play</a></p>
<h3 id="装饰方法"><a href="#装饰方法" class="headerlink" title="装饰方法"></a>装饰方法</h3><p>TypeScript 属性方法接口如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">declare</span> <span class="keyword">type</span> MethodDecorator = &lt;T&gt;(target: <span class="keyword">Object</span>, propertyKey: <span class="keyword">string</span> | symbol, <span class="keyword">descriptor</span>: TypedPropertyDescriptor&lt;T&gt;) =&gt; TypedPropertyDescriptor&lt;T&gt; | <span class="built_in">void</span>;</div></pre></td></tr></table></figure>
<p>方法装饰器接受三个参数，返回属性描述符或者没有返回。这次我们装饰 <code>showPower</code>方法，给它添加 <code>@logMethod</code> 装饰器：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> name: string</div><div class="line">    <span class="keyword">public</span> power: string</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(name:string, power:string)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name</div><div class="line">        <span class="keyword">this</span>.power = power</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@logMethod</span></div><div class="line">    showPower()&#123;</div><div class="line">        <span class="keyword">return</span> `$&#123;<span class="keyword">this</span>.name&#125; has special power: $&#123;<span class="keyword">this</span>.power&#125;`</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译为 JavaScript 得到：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Hero = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Hero</span><span class="params">(name, power)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.power = power;</div><div class="line">    &#125;</div><div class="line">    Hero.prototype.showPower = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">" has special power: "</span> + <span class="keyword">this</span>.power;</div><div class="line">    &#125;;</div><div class="line">    __decorate([</div><div class="line">        logMethod</div><div class="line">    ], Hero.prototype, <span class="string">"showPower"</span>, <span class="literal">null</span>);</div><div class="line">    <span class="keyword">return</span> Hero;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>此时 <code>__decoreate</code> 函数去掉条件判断得到：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> __decorate = (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.__decorate) || <span class="function"><span class="keyword">function</span>(<span class="params">decorators, target, key, desc</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> c = <span class="built_in">arguments</span>.length,</div><div class="line">        r = desc || <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key),</div><div class="line">        d;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = decorators.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">        <span class="keyword">if</span> (d = decorators[i]) r = d(target, key, r) || r;</div><div class="line">    <span class="keyword">return</span> r &amp;&amp; <span class="built_in">Object</span>.defineProperty(target, key, r), r;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>下面我们来实现 <code>@logMethod</code> 装饰器：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logMethod</span><span class="params">(target:any, key:string, descriptor: object)</span></span>&#123;</div><div class="line">  <span class="keyword">var</span> originalMethod = descriptor.value; </div><div class="line"></div><div class="line">  descriptor.value =  <span class="function"><span class="keyword">function</span> <span class="params">(<span class="rest_arg">...args</span>: any[])</span> </span>&#123;</div><div class="line">      <span class="keyword">var</span> a = args.map(a =&gt; JSON.stringify(a)).join();</div><div class="line">      <span class="keyword">var</span> result = originalMethod.apply(<span class="keyword">this</span>, args);</div><div class="line">      <span class="keyword">var</span> r = JSON.stringify(result);</div><div class="line">      console.log(`Call: $&#123;key&#125;($&#123;a&#125;) =&gt; $&#123;r&#125;`);</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> descriptor;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="http://www.typescriptlang.org/Playground#src=class%20Hero%20%7B%0D%0A%20%20%20%20public%20name%3A%20string%3B%0D%0A%20%20%20%20public%20power%3A%20string%3B%0D%0A%0D%0A%20%20%20%20constructor(name%3A%20string%2C%20power%3A%20string)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.name%20%3D%20name%0D%0A%20%20%20%20%20%20%20%20this.power%20%3D%20power%0D%0A%20%20%20%20%7D%0D%0A%0D%0A%20%20%20%20%40logMethod%0D%0A%20%20%20%20showPower()%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20%60%24%7Bthis.name%7D%20has%20special%20power%3A%20%24%7Bthis.power%7D%60%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Afunction%20logMethod(target%3A%20Object%2C%20key%3Astring%2C%20descriptor%3A%20TypedPropertyDescriptor%3Cany%3E)%7B%0D%0A%20%20var%20originalMethod%20%3D%20descriptor.value%3B%20%0D%0A%0D%0A%20%20%2F%2Fediting%20the%20descriptor%2Fvalue%20parameter%0D%0A%20%20descriptor.value%20%3D%20%20function%20(...args%3A%20any%5B%5D)%20%7B%0D%0A%20%20%20%20%20%20var%20a%20%3D%20args.map(a%20%3D%3E%20JSON.stringify(a)).join()%3B%0D%0A%20%20%20%20%20%20%2F%2F%20note%20usage%20of%20originalMethod%20here%0D%0A%20%20%20%20%20%20var%20result%20%3D%20originalMethod.apply(this%2C%20args)%3B%0D%0A%20%20%20%20%20%20var%20r%20%3D%20JSON.stringify(result)%3B%0D%0A%20%20%20%20%20%20console.log(%60Call%3A%20%24%7Bkey%7D(%24%7Ba%7D)%20%3D%3E%20%24%7Br%7D%60)%3B%0D%0A%20%20%20%20%20%20return%20result%3B%0D%0A%20%20%7D%0D%0A%0D%0A%20%20%2F%2F%20return%20edited%20descriptor%20as%20opposed%20to%20overwriting%20%0D%0A%20%20%2F%2F%20the%20descriptor%20by%20returning%20a%20new%20descriptor%0D%0A%20%20return%20descriptor%3B%0D%0A%7D%0D%0A%0D%0Anew%20Hero('batman'%2C%20'fly').showPower()" target="_blank" rel="external">play</a></p>
<h3 id="装饰参数"><a href="#装饰参数" class="headerlink" title="装饰参数"></a>装饰参数</h3><p>TypeScript 参数装饰器接口如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">declare</span> <span class="keyword">type</span> ParameterDecorator = (target: <span class="keyword">Object</span>, propertyKey: <span class="keyword">string</span> | symbol, parameterIndex: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span>;</div></pre></td></tr></table></figure>
<p>参数装饰器也接受三个参数：</p>
<ul>
<li>对象</li>
<li>属性名</li>
<li>参数索引</li>
</ul>
<p>我们给 <code>showPower</code> 函数添加一个表示连击次数的参数，并用 <code>@logParameter</code> 装饰它：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">class</span> Hero &#123;</div><div class="line">    public <span class="built_in">name</span>: <span class="built_in">string</span></div><div class="line">    public power: <span class="built_in">string</span></div><div class="line"></div><div class="line">    constructor(<span class="built_in">name</span>:<span class="built_in">string</span>, power:<span class="built_in">string</span>)&#123;</div><div class="line">        this.<span class="built_in">name</span> = <span class="built_in">name</span></div><div class="line">        this.power = power</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    showPower(@logParameter <span class="built_in">time</span>:<span class="built_in">number</span>)&#123;</div><div class="line"><span class="built_in">        return</span> `$&#123;<span class="built_in">time</span>&#125; <span class="keyword">times</span> power damage`</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译为 JavaScript 得到：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Hero = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Hero</span><span class="params">(name, power)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.power = power;</div><div class="line">    &#125;</div><div class="line">    Hero.prototype.showPower = <span class="function"><span class="keyword">function</span> <span class="params">(time)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> time + <span class="string">" times power damage"</span>;</div><div class="line">    &#125;;</div><div class="line">    __decorate([</div><div class="line">        __param(<span class="number">0</span>, logParamater)</div><div class="line">    ], Hero.prototype, <span class="string">"showPower"</span>, <span class="literal">null</span>);</div><div class="line">    <span class="keyword">return</span> Hero;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>观察 <code>__decorate</code> 函数，我们发现这里调用了另外一个 <code>__param</code> 函数，<code>__param</code> 函数实现如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> __param = (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.__param) || <span class="function"><span class="keyword">function</span> <span class="params">(paramIndex, decorator)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(target, key)</span> </span>&#123; decorator(target, key, paramIndex); &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>__param</code> 函数接受两个参数，参数索引和装饰器函数，返回一个装饰器函数的包装函数。</p>
<p>简化后的 <code>__decorate</code> 函数和上面的方法装饰器得到的一样。</p>
<p>下面我们来实现 <code>@logParameter</code> 装饰器函数：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span></span> logParameter(<span class="keyword">target</span>: Object, key : string, <span class="built_in">index</span> : <span class="keyword">number</span>) &#123;</div><div class="line">  var metadataKey = `log_$&#123;key&#125;_parameters`;</div><div class="line">  <span class="keyword">if</span> (Array.isArray(<span class="keyword">target</span>[metadataKey])) &#123;</div><div class="line">    <span class="keyword">target</span>[metadataKey].push(<span class="built_in">index</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123; </div><div class="line">    <span class="keyword">target</span>[metadataKey] = [<span class="built_in">index</span>];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>logParameter</code> 函数在 <code>Hero.prototype</code> 上添加了一个属性 <code>log_showPower_parameters</code> 用来记录<code>showPower</code>函数被装饰参数的索引。</p>
<p>参数装饰器不支持改变构造器、方法或属性的行为，它只应该用来生成一些元数据。</p>
<h3 id="给装饰器传入参数"><a href="#给装饰器传入参数" class="headerlink" title="给装饰器传入参数"></a>给装饰器传入参数</h3><p>我们可以通过装饰器构造函数来创建可配置的装饰器。下面创建一个可配置的类装饰器：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@logClassWithArgs</span>(&#123;<span class="string">sex:</span> <span class="string">"male"</span>&#125;)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span> &#123;</span> </div><div class="line">  <span class="keyword">public</span> <span class="string">name:</span> string;</div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">function logClassWidthArgs(<span class="string">options:</span> Object)&#123;</div><div class="line">  <span class="keyword">return</span> (<span class="string">target:</span> Object) =&gt;&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>装饰器非常的强大，我们可以使用装饰器大量的简化代码，Angular2 中也大量使用了装饰器，比如 <code>@Component()</code>、<code>@view()</code>、<code>@Input()</code>、<code>@Output()</code>、<code>@Injectable()</code>等。后面<br>将会深入写 Angular2 中的装饰器。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://github.com/wycats/javascript-decorators" target="_blank" rel="external">javascript-decorators提案</a>以及 <a href="https://github.com/xuhong/javascript-decorators" target="_blank" rel="external">我的翻译版本</a></li>
<li><a href="http://blog.wolksoftware.com/decorators-reflection-javascript-typescript" target="_blank" rel="external">decorators-reflection-javascript-typescript</a></li>
<li><a href="http://stackoverflow.com/questions/29775830/how-to-implement-a-typescript-decorator/29837695#29837695" target="_blank" rel="external">How to implement a typescript decorator?</a></li>
<li><a href="https://github.com/GoogleChrome/samples/tree/gh-pages/decorators-es7/read-write" target="_blank" rel="external">Google ES7 decorators sample</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;装饰器是 ES7（也就是ES2016）的提案，虽然听着感觉好像还有点遥远，毕竟 ES6 还没有走多久呢，但实际上，2016年已经到来，也就是说，ES7 的提案今年就会成为新的标准，同时借助一些编译器（比如babel），我们早已经可以在正式环境中使用它了。另外，TypeScript 在去年和&lt;br&gt;AtScript 合并后发布的 1.5 版本，就已经支持装饰器语法了。基于 TypeScript 开发的 Angular2 里面也大量的使用了装饰器。&lt;/p&gt;
&lt;h2 id=&quot;什么是装饰器&quot;&gt;&lt;a href=&quot;#什么是装饰器&quot; class=&quot;headerlink&quot; title=&quot;什么是装饰器&quot;&gt;&lt;/a&gt;什么是装饰器&lt;/h2&gt;&lt;p&gt;用提案的描述来说，装饰器是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个求值结果为函数的表达式，接受目标对象、名称和装饰器描述作为参数，可选地返回一个装饰器描述来安装到目标对象上。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="typescript" scheme="http://codersir.github.io/tags/typescript/"/>
    
      <category term="es2016" scheme="http://codersir.github.io/tags/es2016/"/>
    
      <category term="decorator" scheme="http://codersir.github.io/tags/decorator/"/>
    
  </entry>
  
  <entry>
    <title>深入学习 Redux</title>
    <link href="http://codersir.github.io/2016/01/25/dive-into-redux/"/>
    <id>http://codersir.github.io/2016/01/25/dive-into-redux/</id>
    <published>2016-01-25T08:33:25.000Z</published>
    <updated>2016-07-10T13:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们谈 Redux 的时候，一般都会把它和 React 联系到一起。但是，Redux 作为一种状态管理方案，并不限于和 React 一起使用，你可以扩展到其他任何合适的框架，比如 Angular。Redux 的目标是 <strong>使状态的改变可预测</strong>。Redux 通过下面三个原则约束来实现这一目标：</p>
<ul>
<li>单一数据源：整个应用的状态都存在单一 store 的对象树里面</li>
<li>状态只读：改变状态的唯一方法就是触发一个 action，action 是一个描述发生了什么的对象</li>
<li>变化都由纯函数生成：通过 reducers 来指定状态树怎么被 action 转化</li>
</ul>
<p>Redux 中有3个概念，分别是：</p>
<ul>
<li>action</li>
<li>reducer</li>
<li>store</li>
</ul>
<p>它们之间的转换流程图如下：<br><img src="/image/blog/redux-flow.png" alt="Redux-flow"></p>
<h3 id="什么是-action"><a href="#什么是-action" class="headerlink" title="什么是 action"></a>什么是 action</h3><p>action 是简单的 JavaScript 对象，包含一个值唯一的 <code>type</code> 属性用<strong>来描述状态的变化</strong>。比如添加评论的 action:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attribute">type</span>: <span class="string">'ADD_COMMENT'</span>,</div><div class="line">  content: <span class="string">'add a comment'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通常我们会写个 action creator 用来帮助创建 action，简化输入：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">addComment</span>(text)&#123;</div><div class="line">  <span class="selector-tag">return</span> &#123;</div><div class="line">    <span class="attribute">type</span>: <span class="string">'ADD_COMMENT'</span>,</div><div class="line">    <span class="attribute">content</span>: text,</div><div class="line">    <span class="attribute">create_at</span>: Date.now()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果 action creator 需要读取当前状态或者调用 API，或者进行其他有副作用的操作，比如路由过渡，那么它应该返回 <code>async action</code> 而不是 <code>action</code>。</p>
<p>async action（异步操作）是准备传递给 <code>dispatch()</code> 函数但却还没准备好被 <code>reducer</code> 调用的 <code>action</code>，它们会在传递给 <code>dispatch()</code> 函数前被 <code>middleware(中间件)</code> 转化为 <code>action</code>。</p>
<p>action 的结构并没有什么限制，只要是 JavaScript 对象并且包含 <code>type</code> 字段即可。当然，为了团队协作和编码风格的统一，有个规范总是好的，可以通过<a href="https://github.com/acdlite/redux-actions" target="_blank" rel="external">redux-actions</a> 来写 FSA(Flux Standard Action)。</p>
<h3 id="reducer-怎么工作"><a href="#reducer-怎么工作" class="headerlink" title="reducer 怎么工作"></a>reducer 怎么工作</h3><p>reducer 就对应这个名称来源，是 Redux 中最重要的概念。和 <code>arr.reduce</code> 方法类似，它的用法是传入当前状态和要进行的操作，返回下一个状态：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">previousState</span>, action) =&gt; newState</div></pre></td></tr></table></figure>
<p><strong>reducer 根据 action 的描述来改变 state</strong>。<strong>reducer 必须是纯函数</strong>,也就是说：</p>
<ul>
<li>返回值和传入的值结构一致</li>
<li>没有副作用</li>
</ul>
<p>所以下列事情不应该在 <code>reducer</code> 中进行：</p>
<ul>
<li>改变传入的参数值</li>
<li>进行有副作用的操作，比如调用API和路由过渡</li>
<li>调用非纯函数，比如 <code>Date.now()</code> 和 <code>Math.random()</code></li>
</ul>
<p>通常，我们会根据职能分工不同分割成多个 reducer，对于这种情况，Redux 提供了 <code>combineReducers</code> 函数来把它们结合到一起：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span> (<span class="params">reducers</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</div><div class="line">  <span class="keyword">var</span> finalReducers = &#123;&#125;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> key = reducerKeys[i]</div><div class="line">    <span class="comment">// 过滤掉不合法的 reducer</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'function'</span>) &#123;</div><div class="line">      finalReducers[key] = reducers[key]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> finalReducerKeys = <span class="built_in">Object</span>.keys(finalReducers)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span> (<span class="params">state = &#123;&#125; , action</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> hasChanged = <span class="literal">false</span></div><div class="line">    <span class="keyword">var</span> nextState = &#123;&#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</div><div class="line">      <span class="keyword">var</span> key = finalReducerKeys[i]</div><div class="line">      <span class="keyword">var</span> reducer = finalReducers[key]</div><div class="line">      <span class="keyword">var</span> previousStateForKey = state[key]</div><div class="line">      <span class="keyword">var</span> nextStateForKey = reducer(previousStateForKey, action)</div><div class="line">      <span class="comment">// 不能返回 undefined</span></div><div class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> nextStateForKey === <span class="string">'undefined'</span>) &#123;</div><div class="line">        <span class="keyword">var</span> errorMessage = getUndefinedStateErrorMessage(key, action)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(errorMessage)</div><div class="line">      &#125;</div><div class="line">      nextState[key] = nextStateForKey</div><div class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hasChanged ? nextState : state</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>combineReducers</code> 函数是个闭包，它的作用是返回一个调用 reducers 的函数，调用每个 reducer 函数时传入 key 值对应的 state 片段作为相应 reducer 的初始 state。</p>
<p>需要注意的是：</p>
<ol>
<li><strong>我们不改变 state 而是返回它的一个副本</strong>，可以通过 <code>Object.assign({}, state, newState)</code> 或 对象展开操作符 <code>{...state, ...newState}</code> 来完成。</li>
<li><strong>任何时候 reducer 都不应该返回 <code>undefined</code></strong>，如果下一个状态为 <code>undefined</code>，那么就返回它之前的状态，否则 Redux 会报错。</li>
</ol>
<h3 id="store-是什么"><a href="#store-是什么" class="headerlink" title="store 是什么"></a>store 是什么</h3><p><strong>store 用来存储应用的状态</strong>。在 Redux 中，store 是状态的中心，提供以下 API：</p>
<ul>
<li>通过 <code>store.dispatch(action)</code> 分发 action</li>
<li>通过 <code>store.subscribe(callback)</code> 添加事件监听，触发时调用回调函数</li>
<li><code>store.subscribe(callback)</code> 返回一个函数，调用这个函数注销事件监听</li>
</ul>
<p>一个应用只有一个 <code>store</code>，它包含该应用完整的状态树。我们通过调用 <code>createStore</code> 函数来创建 store：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</div><div class="line">    enhancer = preloadedState</div><div class="line">    preloadedState = <span class="literal">undefined</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// enhancer 通常为 applyMiddleware 函数调用后返回的函数</span></div><div class="line">    <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">  <span class="comment">// 返回 store 对象</span></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    dispatch,</div><div class="line">    subscribe,</div><div class="line">    getState,</div><div class="line">    replaceReducer,</div><div class="line">    [$$observable]: observable</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>createStore</code> 最终返回一个 store 对象，包含 <code>dispatch</code>、<code>getState</code> 等方法。如果给 <code>createStore</code> 函数传入了 enhancer，那么就会先调用 enhancer 函数。enhancer 函数通常是一些中间件，被 <code>applyMiddleware</code> 函数调用后返回改变了 <code>dispatch</code> 函数行为的 store 对象。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span><span class="params">(<span class="rest_arg">...middlewares</span>)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123;</div><div class="line">    <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer)</div><div class="line">    <span class="keyword">var</span> dispatch = store.dispatch</div><div class="line">    <span class="keyword">var</span> chain = []</div><div class="line">    <span class="comment">// 对 middleware 只暴露 getState 和 dispatch 这两个 API</span></div><div class="line">    <span class="keyword">var</span> middlewareAPI = &#123;</div><div class="line">      getState: store.getState,</div><div class="line">      dispatch: (action) =&gt; dispatch(action)</div><div class="line">    &#125;</div><div class="line">    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))</div><div class="line">    dispatch = compose(...chain)(store.dispatch) <span class="comment">//</span></div><div class="line">    <span class="comment">// 返回新的 dispatch</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      ...store,</div><div class="line">      dispatch</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么新的 dispatch 函数究竟是怎样的呢？这里调用了 <code>compose</code> 函数，<code>compose</code> 函数实现如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span> <span class="params">(<span class="rest_arg">...funcs</span>)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> arg =&gt; arg</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> last = funcs[funcs.length - <span class="number">1</span>]</div><div class="line">  <span class="keyword">const</span> rest = funcs.slice(<span class="number">0</span>, <span class="number">-1</span>)</div><div class="line">  <span class="keyword">return</span> (...args) =&gt; rest.reduceRight((composed, f) =&gt; f(composed), last(...args))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>compose</code> 函数的作用就是把中间件组合起来，通过 <code>Array.reduceRight</code> 函数实现柯里化，比如有两个中间件返回函数 f 和 g，被 compose 函数调用后结果为：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">compose(f,g)(store.dispatch) <span class="comment">// 得到 f(g(store.dispatch))，注意我们把 store.dispatch 作为初始值</span></div></pre></td></tr></table></figure>
<p>这样处理后，以后每次调用 <code>store.dispatch</code> 函数时，都会依次穿过各个中间件，得到链式调用中间件的效果，有一点 express 中间件的感觉了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redux 的代码非常简单，也很好理解，作者在 gist 有一个<a href="https://gist.github.com/gaearon/ffd88b0e4f00b22c3159" target="_blank" rel="external">瘦身版的 Redux</a>，去掉了不必要的条件判断和错误处理，只有百来行代码。虽然简单，但它背后的思想非常值得玩味，比如单一数据源、纯函数等。另外，Redux 作者的表达能力非常好，这一点在文档上得到了充分的展示，对一些概念的解释非常老练，由浅入深，层层推进，真是让人佩服。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://redux.js.org/" target="_blank" rel="external">redux doc</a></li>
<li><a href="https://gist.github.com/gaearon/ffd88b0e4f00b22c3159" target="_blank" rel="external">slim-redux.js</a></li>
<li><a href="https://egghead.io/series/getting-started-with-redux" target="_blank" rel="external">Getting Started with Redux</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们谈 Redux 的时候，一般都会把它和 React 联系到一起。但是，Redux 作为一种状态管理方案，并不限于和 React 一起使用，你可以扩展到其他任何合适的框架，比如 Angular。Redux 的目标是 &lt;strong&gt;使状态的改变可预测&lt;/strong&gt;。
    
    </summary>
    
    
      <category term="react" scheme="http://codersir.github.io/tags/react/"/>
    
      <category term="redux" scheme="http://codersir.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 入门教程</title>
    <link href="http://codersir.github.io/2016/01/12/learn-typescript/"/>
    <id>http://codersir.github.io/2016/01/12/learn-typescript/</id>
    <published>2016-01-12T04:58:51.000Z</published>
    <updated>2016-07-21T12:13:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript 是微软出的一个 JavaScript 超集，给 JavaScript 添加了类型，可以编译成 plain JavaScript。最近开始学习Angular2，Angular2 支持 TypeScript 来编写，也是社区推荐的方式。</p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>TypeScript 为你添加了你期望 JavaScript 拥有的基本数据类型：numbers、strings、structures、boolean、array、enum 等。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;    <span class="comment">//boolean</span></div><div class="line"><span class="keyword">var</span> height: <span class="built_in">number</span> = <span class="number">6</span>;         <span class="comment">//number</span></div><div class="line"><span class="keyword">var</span> name:<span class="built_in">string</span> = <span class="string">'xuhong'</span>;     <span class="comment">//string</span></div><div class="line"><span class="keyword">var</span> list:<span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];    <span class="comment">//array</span></div><div class="line"><span class="keyword">var</span> list:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]<span class="comment">//generic array type</span></div><div class="line"></div><div class="line"><span class="keyword">enum</span> Color &#123;Red:<span class="number">1</span>, Green, Blue&#125;</div><div class="line"><span class="keyword">var</span> c: Color = Color.Red;       <span class="comment">//enum</span></div><div class="line"><span class="keyword">var</span> colorName:<span class="built_in">string</span> = Color[<span class="number">2</span>] <span class="comment">//get enum value use number</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> notSure:<span class="built_in">any</span> = <span class="number">4</span>;            <span class="comment">//any</span></div><div class="line">notSure = <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">warning</span>:<span class="title">void</span></span>&#123;          <span class="comment">//no return value's function's return type is void</span></div><div class="line">    <span class="built_in">console</span>.warning(<span class="string">'warning message'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h3><p>TypeScript 的一个主要原则是采用鸭式辩形或者说是构造子类来进行类型检查。在 TypeScript 中，接口就是充当这样的角色来命名这些类型，同时也是你项目内部代码以及和外部代码进行协作的有效方式。</p>
<p>当不使用接口时，我们这样写代码：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function sayHello(person: &#123;<span class="built_in">name</span>: <span class="built_in">string</span>&#125;) &#123;</div><div class="line">    console.<span class="built_in">log</span>(<span class="string">"hello "</span> + person.<span class="built_in">name</span>)</div><div class="line">&#125;</div><div class="line">var <span class="keyword">me</span> = &#123;<span class="built_in">name</span>: 'xuhong', age: <span class="number">24</span>&#125;</div><div class="line">sayHello(<span class="keyword">me</span>)</div></pre></td></tr></table></figure>
<p>sayHello 函数接受一个参数，该参数必须是个对象并且有一个名为 <code>name</code> 的属性。虽然传入的对象还有其他的属性，但是编译器只会检查必须的属性以及它的类型。下面用接口重新写这个函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> personName &#123;</div><div class="line">    name: <span class="built_in">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">person: personName</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"hello "</span> + person.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> me = &#123;name: <span class="string">'xuhong'</span>, age: <span class="number">24</span>&#125;</div><div class="line">sayHello(me)</div></pre></td></tr></table></figure>
<p>现在我们可以使用接口 <code>personName</code> 来描述参数的要求。注意我们不需要像其他的语言一样写明我们传进 <code>sayHello</code> 的对象实现了这个接口，只要这个对象满足接口列出的所有要求就够了。<br>另外，并不是所有的参数都是必须的，接口也支持可选参数，在属性名后面添加一个 ? 表明这个属性是可选的。</p>
<h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>接口可以描述许多 JavaScript 对象的形状。除了可以描述拥有属性的对象，接口也可以描述函数类型。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SearchFunc</span> &#123;</span></div><div class="line">    (<span class="string">source:</span> string, <span class="string">subString:</span> string): <span class="keyword">boolean</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">var <span class="string">mySearch:</span> SearchFunc</div><div class="line">mySearch = functiuon(<span class="string">src:</span> string, <span class="string">sub:</span> string)&#123;</div><div class="line">    <span class="keyword">return</span> src.search(sub) == <span class="number">-1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>以及描述数组类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> StringArray &#123;</div><div class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myArr: stringArray</div><div class="line">myArr = [<span class="string">'abc'</span>, <span class="string">'def'</span>]</div></pre></td></tr></table></figure>
<p>TypeScript 支持两种索引类型：数字和字符串。而且可以同时支持两种索引，但是要求数字索引返回的值是字符串索引返回的值的子类。它也要求所有的属性匹配它们的返回值类型，下面的例子会被类型检查器报错，因为length属性的类型和索引的类型不匹配</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Dictionary &#123;</div><div class="line">    [index: <span class="built_in">string</span>]: <span class="built_in">string</span>;</div><div class="line">    length: <span class="built_in">number</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h4><p>当类实现接口时，只有类的实例部分会被检查，构造器部分是静态部分，不会被检查。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> ClockInterface <span class="comment">&#123;</span></div><div class="line">    currentTime: Date;</div><div class="line">    setTime(d: date);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Clock impletements ClockInterface <span class="comment">&#123;</span></div><div class="line">    currentTime: Date;</div><div class="line">    setTime(d: date) &#123;</div><div class="line">        this.currentTime = d</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">constructor</span><span class="params">(h: number, m: number)</span> <span class="comment">&#123;&#125;</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="扩展接口"><a href="#扩展接口" class="headerlink" title="扩展接口"></a>扩展接口</h4><p>像类一样，接口也可以彼此扩展对方：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Shape &#123;</div><div class="line">    color: <span class="built_in">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape &#123;</div><div class="line">    sideLength: <span class="built_in">number</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> square = &lt;Square&gt;&#123;&#125;;</div><div class="line">square.color = <span class="string">'blue'</span>;</div><div class="line">square.sideLength = <span class="number">10</span>;</div></pre></td></tr></table></figure>
<h4 id="组合类型"><a href="#组合类型" class="headerlink" title="组合类型"></a>组合类型</h4><p>接口可以描述 JavaScript 中许多的类型，有时候你可能会遇到一个对象充当上述几种类型的组合。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">interface Counter &#123;</div><div class="line">    (start: number): string<span class="comment">;</span></div><div class="line"><span class="symbol">    interval:</span> number<span class="comment">;</span></div><div class="line">    reset(): void<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">var c: Counter<span class="comment">;</span></div><div class="line">c(<span class="number">10</span>)<span class="comment">;</span></div><div class="line">c.reset()<span class="comment">;</span></div><div class="line">c.interval = <span class="number">5</span>.<span class="number">0</span><span class="comment">;</span></div></pre></td></tr></table></figure>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>没有类以前，JavaScript 的继承主要通过原型来实现，ES6 给 JavaScript 添加了类以后，我们也可以采用基于类的面向对象方式来实现继承了。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> name: string;</div><div class="line">    constructor(theName:string)&#123;</div><div class="line">        <span class="keyword">this</span>.name = theName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rhino</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">    constructor()&#123; <span class="keyword">super</span>(<span class="symbol">'Rhin</span>o')</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> <span class="type">Animal</span>(<span class="symbol">'Goa</span>t');</div><div class="line"><span class="keyword">var</span> rhino = <span class="keyword">new</span> <span class="type">Rhino</span>();</div></pre></td></tr></table></figure>
<p>TypeScript 给类添加了 公开/私有（public/priviate）属性声明，默认所有的属性都是公开的。另外，<code>priviate</code> 和 <code>public</code> 关键字用在初始化函数参数的属性声明时，可以作为创建并初始化类成员的便捷方式。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</div><div class="line">    constructor(<span class="keyword">private</span> name: <span class="keyword">string</span>) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>TypeScript 支持 getters/setters 拦截对象成员的存取。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> passcode = <span class="string">"secret passcode"</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</div><div class="line">    <span class="keyword">private</span> _fullName: <span class="keyword">string</span>;</div><div class="line">    <span class="function"><span class="keyword">get</span> <span class="title">fullName</span>(<span class="params"></span>): <span class="keyword">string</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._fullName;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">set</span> <span class="title">fullName</span>(<span class="params">newName: <span class="keyword">string</span></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">"secret passcode"</span>) &#123;</div><div class="line">            <span class="keyword">this</span>._fullName = newName;</div><div class="line">        &#125; <span class="keyword">else</span>&#123;</div><div class="line">            alert(<span class="string">"Error: Unauthorized update of employee!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> employee = <span class="keyword">new</span> Employee();</div><div class="line">employee.fullName = <span class="string">"Bob Smith"</span>;</div><div class="line"><span class="keyword">if</span> (employee.fullName) &#123;</div><div class="line">    alert(employee.fullName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TypeScript 支持静态属性声明，所有的静态属性只在类的内部可见，类的实例无法访问静态属性。在类的内部，通过在静态属性名前添加类名前缀来访问该属性(className.staticPropertity)。<br>另外，因为类创建类型，所以你也可以在某些地方用它们替代接口。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></div><div class="line"><span class="symbol">    x:</span> number;</div><div class="line"><span class="symbol">    y:</span> number;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Point3d</span> <span class="keyword">extends</span> <span class="title">Point</span> &#123;</span></div><div class="line"><span class="symbol">    z:</span> number;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var <span class="string">point3d:</span> Point3d = &#123;<span class="string">x:</span><span class="number">1</span>, <span class="string">y:</span><span class="number">2</span>, <span class="string">z:</span><span class="number">3</span>&#125;</div></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>和 JavaScript 一样，函数可以被定义为命名函数和匿名函数。在 JavaScript 中，这两种命名方式如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// <span class="keyword">named</span> <span class="function"><span class="keyword">function</span></span></div><div class="line"><span class="function"><span class="keyword">function</span></span> add(x, y)&#123;</div><div class="line">    <span class="keyword">return</span> x+y</div><div class="line">&#125;</div><div class="line">// Anonymous <span class="function"><span class="keyword">function</span></span></div><div class="line">var myAdd = <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> x+y</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="函数类型-1"><a href="#函数类型-1" class="headerlink" title="函数类型"></a>函数类型</h4><p>在 TypeScript 中，我们给上面的函数加上类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> x+y</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myAdd: (x:<span class="built_in">number</span>, y:<span class="built_in">number</span>)=&gt;<span class="built_in">number</span>  = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>)</span>&#123; <span class="keyword">return</span> x+y &#125;</div><div class="line"><span class="comment">// 上面的写法太冗余了，TypeScript 可以通过‘上下文类型‘推断出函数的类型：</span></div><div class="line"><span class="keyword">var</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x+y &#125;</div><div class="line"><span class="keyword">var</span> myAdd: (baseValue:<span class="built_in">number</span>, increment:<span class="built_in">number</span>)=&gt;<span class="built_in">number</span> = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123; <span class="keyword">return</span> x+y &#125;</div></pre></td></tr></table></figure>
<h4 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h4><p>和 JavaScript 不一样的是，TypeScript 默认所有参数都是必须的。但是我们可以在参数后面添加 ‘?’ 来表示该参数是可选的。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="title">buildName</span>(firstName: string, middleName?: string, lastName = "xuhong)&#123;</div><div class="line">    if(middleName)&#123; <span class="keyword">return</span> <span class="type">firstName</span> + <span class="string">" "</span> + middleName + <span class="string">" "</span> + lastName &#125;</div><div class="line">    <span class="keyword">else</span> &#123; <span class="keyword">return</span> firstName + <span class="string">" "</span> + lastName &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>剩余参数是一个参数数组，让你可以一次传入任意数量的参数：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//restOfName is an Array</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span><span class="params">(firstName: string, <span class="rest_arg">...restOfName</span>: string[])</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> firstName + <span class="string">" "</span> + restOfName.join(<span class="string">" "</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myname = buildName(<span class="string">"chen"</span>,<span class="string">"xuhong"</span>,<span class="string">"codersir"</span>)</div></pre></td></tr></table></figure>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>重载我们都很熟悉，就是根据传入的参数的不同进行不同的操作或返回不同的值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: &#123;suit: <span class="built_in">string</span>; card: <span class="built_in">number</span>; &#125;[]</span>): <span class="title">number</span></span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: <span class="built_in">number</span></span>): </span>&#123;suit: <span class="built_in">string</span>; card: <span class="built_in">number</span>; &#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>): <span class="title">any</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> x == <span class="string">"object"</span>)&#123;</div><div class="line">        <span class="keyword">var</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x.length);</div><div class="line">        <span class="keyword">return</span> pickedCard;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"number"</span>)&#123;</div><div class="line">        <span class="keyword">var</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span class="number">13</span>);</div><div class="line">        <span class="keyword">return</span> &#123; suit: suits[pickedSuit], card: x % <span class="number">13</span> &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>软件工程的一个重要部分就是开发不仅具有良好设计和一致的 API，而且还可以复用的组件。在 C# 和 Java 中，泛型就是实现可复用组件的重要工具，泛型使组件可以支持一系列的类型而不仅仅是某一种类型。<br>Angular2 的 Component 就是通过泛型实现复用。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> arg;</div><div class="line">&#125;</div><div class="line"><span class="built_in">var</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">"myString"</span>)</div><div class="line"><span class="built_in">var</span> output = identity(<span class="string">"myString"</span>)           <span class="comment">//type 参数可以省略，编译器可以根据传入的参数推断类型</span></div></pre></td></tr></table></figure>
<h4 id="接口泛型"><a href="#接口泛型" class="headerlink" title="接口泛型"></a>接口泛型</h4><p>接口泛型可以使所有实现该接口的对象元素保持同一种类型：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">interface GenericIdentityFn&lt;<span class="literal">T</span>&gt; &#123;</div><div class="line">    (arg: <span class="literal">T</span>): <span class="literal">T</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> identity&lt;<span class="literal">T</span>&gt;(arg: <span class="literal">T</span>): <span class="literal">T</span> &#123;</div><div class="line">    <span class="keyword">return</span> arg;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var myIdentity: GenericIdentityFn&lt;number&gt; = identity;</div></pre></td></tr></table></figure>
<h4 id="类泛型"><a href="#类泛型" class="headerlink" title="类泛型"></a>类泛型</h4><p>和接口泛型一样，类泛型可以确保所有的成员都是同一种类型。但是请注意，泛型只和类的实例部分相关，类的静态部分可以是其他的类型。</p>
<h4 id="约束泛型"><a href="#约束泛型" class="headerlink" title="约束泛型"></a>约束泛型</h4><p>有时候，我们不仅仅要求组件可以支持所有的类型，还会有其他的限制，比如要求至少有一个 length 属性：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Lengthwise &#123;</div><div class="line">    length: <span class="keyword">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span></span> identity&lt;T <span class="keyword">extends</span> Lengthwise&gt;(arg: T): T &#123;</div><div class="line">    console.<span class="built_in">log</span>(arg.length)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="混合（mixin-）"><a href="#混合（mixin-）" class="headerlink" title="混合（mixin ）"></a>混合（mixin ）</h3><p>TypeScript 的 mixin 并不够优雅。在 TypeScript 中，mixin 使用关键字 <code>implements</code> 而不是 <code>extends</code>，这意味着类被当成接口来使用，所以只会检查被混合类成员的类型而不是实现，也就是说我们必须在混合后的类中提供类成员的实现。然而这正是我们使用 mixin 想要避免的。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disposable</span> &#123;</span></div><div class="line">    isDisposed: boolean;</div><div class="line">    dispose() &#123;</div><div class="line">        <span class="keyword">this</span>.isDisposed = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activatable</span> &#123;</span></div><div class="line">    isActive: boolean;</div><div class="line">    activate() &#123;</div><div class="line">        <span class="keyword">this</span>.isActive = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">smartObj</span> <span class="title">implements</span> <span class="title">Disposable</span>, <span class="title">Activatable</span> &#123;</span></div><div class="line">    constructor() &#123;</div><div class="line">        setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.isActive + <span class="string">":"</span> + <span class="keyword">this</span>.isDisposed), <span class="number">500</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    interact() &#123;</div><div class="line">        <span class="keyword">this</span>.activate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="regexp">//</span>这里要再写一遍</div><div class="line">    isDisposed: boolean = <span class="literal">false</span>;</div><div class="line">    dispose: <span class="function"><span class="params">()</span> =&gt;</span> void;</div><div class="line">    isActive: boolean = <span class="literal">false</span>;</div><div class="line">    activate: <span class="function"><span class="params">()</span> =&gt;</span> void;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h3><p>在 TypeScript 中，声明无非三种：命名空间/模块，类型，值。</p>
<h4 id="合并接口"><a href="#合并接口" class="headerlink" title="合并接口"></a>合并接口</h4><p>同名接口合并其成员：</p>
<ul>
<li>非函数成员必须唯一。</li>
<li>函数成员视为重载。</li>
</ul>
<h4 id="合并模块"><a href="#合并模块" class="headerlink" title="合并模块"></a>合并模块</h4><p>声明模块会同时创建命名空间和值：</p>
<ul>
<li>命名空间的合并： 每个模块中  <code>export</code> 的类型定义自行合并，组成一个新的命名空间</li>
<li>值的合并：如果模块已经有同名的值，合并时会把第二个模块中 <code>export</code> 的值添加到第一个模块中</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript 是微软出的一个 JavaScript 超集，给 JavaScript 添加了类型，可以编译成 plain JavaScript。最近开始学习Angular2，Angular2 支持 TypeScript 来编写，也是社区推荐的方式。&lt;/p&gt;
&lt;h3 i
    
    </summary>
    
    
      <category term="angular2" scheme="http://codersir.github.io/tags/angular2/"/>
    
      <category term="typescript" scheme="http://codersir.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>盒模型以及 box-sizing</title>
    <link href="http://codersir.github.io/2015/12/08/box-model-and-box-sizing/"/>
    <id>http://codersir.github.io/2015/12/08/box-model-and-box-sizing/</id>
    <published>2015-12-08T05:14:27.000Z</published>
    <updated>2016-05-29T18:17:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两天一个准备入前端坑的朋友问我：标准盒模型到底是什么？我不假思索的说:</p>
<blockquote>
<p>盒模型有两种，一种是 w3c 标准盒模型，一种是 IE 盒模型。标准盒模型就是 <code>width = content_width + padding_width + border_width</code>。</p>
</blockquote>
<p>朋友立马打断我说道：</p>
<blockquote>
<p>不对不对，你又把我搞晕了，这不是 IE 盒模型么？</p>
</blockquote>
<a id="more"></a>
<p>我感觉到有点不对劲了，赶紧 Google 了一下，才发现我真的记反了。这让我大吃一惊，这些基本概念我明明都很清楚的，怎么工作一年后居然把这个都弄混了。然后我突然想起了另一个属性：<code>box-sizing:border-box</code>，我说的盒模型计算公式就是 border-box 啊。自己一直用的 css reset 把 box-sizing 默认设置成 border-box，用的久了慢慢的就忘了它的存在，心想着自己在 chrome 下用的应该是标准的盒模型，就默认把 border-box 当成标准盒模型了。</p>
<p>先来回顾一下标准盒模型和 IE 盒模型，一图胜千言。</p>
<p><img src="/image/blog/box-model.png" alt="盒模型"></p>
<p>所以标准盒模型是不包括 padding 和 border 的，也就是 <code>width=content_width</code>。</p>
<p>那么为什么所有的 reset CSS 的 box-model 都默认是 border-box 呢？因为 border-box 的计算方式<strong>更符合我们的心理预期</strong>，同时也<strong>更方便计算</strong>。设想下面这种情况，我们希望内容宽度100%，同时还有 1em 的边框。</p>
<ul>
<li>如果是 content-box（内容盒模型），则会出现横向滚动条，这显然不是我们想要的</li>
</ul>
<p></p><p data-height="268" data-theme-id="0" data-slug-hash="zrxEVY" data-default-tab="result" data-user="xuhong" class="codepen">See the Pen <a href="http://codepen.io/xuhong/pen/zrxEVY/" target="_blank" rel="external">content-box</a> by 旭鸿 (<a href="http://codepen.io/xuhong" target="_blank" rel="external">@xuhong</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<ul>
<li>border-box（边框盒模型）才是我们预期的展现方式</li>
</ul>
<p></p><p data-height="268" data-theme-id="0" data-slug-hash="gPbGyG" data-default-tab="result" data-user="xuhong" class="codepen">See the Pen <a href="http://codepen.io/xuhong/pen/gPbGyG/" target="_blank" rel="external">border-box</a> by 旭鸿 (<a href="http://codepen.io/xuhong" target="_blank" rel="external">@xuhong</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>通常，最常见的 CSS reset 的 box-sizing 是下面这样的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">*,</div><div class="line">*<span class="selector-pseudo">:before</span>,</div><div class="line">*<span class="selector-pseudo">:after</span>&#123;</div><div class="line">	<span class="attribute">-webkit-border-sizing</span>: border-box;</div><div class="line">	<span class="attribute">-moz-border-sizing</span>: border-box;</div><div class="line">	<span class="attribute">border-sizing</span>: border-box;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是 CSS-Tricks 提供了<a href="https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/" target="_blank" rel="external">一种更好的 box-sizing reset</a>，添加了继承，方便覆盖效率更高，同时去掉了浏览器前缀（国外 IE7 及以下已经不用考虑了）：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">html</span> &#123;</div><div class="line">  <span class="attribute">box-sizing</span>: border-box;</div><div class="line">&#125;</div><div class="line">*, *<span class="selector-pseudo">:before</span>, *<span class="selector-pseudo">:after</span> &#123;</div><div class="line">  <span class="attribute">box-sizing</span>: inherit;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一些资料：</p>
<p>-<a href="https://en.wikipedia.org/wiki/Internet_Explorer_box_model_bug#Background" target="_blank" rel="external">wikipedia: Internet Explorer box model bug</a><br>-<a href="http://caniuse.com/#feat=css3-boxsizing" target="_blank" rel="external">Can i use box-sizing</a><br>-<a href="https://css-tricks.com/box-sizing/" target="_blank" rel="external">CSS-Tricks Box Sizing</a><br>-<a href="https://css-tricks.com/international-box-sizing-awareness-day/" target="_blank" rel="external">International box-sizing Awareness Day</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天一个准备入前端坑的朋友问我：标准盒模型到底是什么？我不假思索的说:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;盒模型有两种，一种是 w3c 标准盒模型，一种是 IE 盒模型。标准盒模型就是 &lt;code&gt;width = content_width + padding_width + border_width&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;朋友立马打断我说道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不对不对，你又把我搞晕了，这不是 IE 盒模型么？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://codersir.github.io/tags/css/"/>
    
  </entry>
  
</feed>
